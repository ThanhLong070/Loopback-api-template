/**
 * BFast_System
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from "querystring";
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "https://localhost/api".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
};

export interface AccessToken {
    "id": string;
    /**
     * time to live in seconds (2 weeks by default)
     */
    "ttl"?: number;
    /**
     * Array of scopes granted to this access token.
     */
    "scopes"?: Array<string>;
    "created"?: Date;
    "userId"?: number;
}

export interface Account {
    "nom"?: string;
    "password"?: string;
    "prenom"?: string;
    "sex"?: string;
    "fonction"?: string;
    "birthday"?: string;
    "specialisation"?: string;
    "categorieSociopro"?: string;
    "addresse"?: string;
    "alerte"?: boolean;
    "domaine"?: string;
    "drivers1"?: string;
    "drivers2"?: string;
    "drivers3"?: string;
    "drivers4"?: string;
    "limitEngagement"?: number;
    "limitAction"?: number;
    "limitTraitement"?: number;
    "limitBarometre"?: number;
    "limitQualitatif"?: number;
    "receiveAlert"?: boolean;
    "poste"?: string;
    "status"?: string;
    "posteDuer"?: string;
    "societeId"?: string;
    "alreadyLogin"?: boolean;
    "realm"?: string;
    "username"?: string;
    "email": string;
    "emailVerified"?: boolean;
    "id"?: number;
    "managerId"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
}

export interface AccountToken {
    "id": string;
    /**
     * time to live in seconds (2 weeks by default)
     */
    "ttl"?: number;
    /**
     * Array of scopes granted to this access token.
     */
    "scopes"?: Array<string>;
    "created"?: Date;
    "userId"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
}

export interface ActiveLog {
    "method"?: string;
    "accessType"?: string;
    "id"?: number;
    "accountId"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
}

export interface Example {
    "property1": string;
    "property2": string;
    "id"?: number;
}

export interface Faq {
    "question"?: string;
    "answer"?: string;
    "id"?: number;
}

export interface InlineResponse200 {
    "count"?: number;
}

export interface InlineResponse2001 {
    "exists"?: boolean;
}

/**
 * Information related to the outcome of the operation
 */
export interface InlineResponse2002 {
    /**
     * The number of instances updated
     */
    "count"?: number;
}

export interface InlineResponse2003 {
    "undefined"?: any;
}

export interface InlineResponse2004 {
    "result"?: any;
}

export interface InlineResponse2005 {
    /**
     * Show that the transaction is created
     */
    "isCompleted"?: boolean;
    /**
     * The return message
     */
    "message"?: string;
}

export interface Installation {
    "appId": string;
    "appVersion"?: string;
    "badge"?: number;
    "created"?: Date;
    "deviceToken": string;
    "deviceType": string;
    "modified"?: Date;
    "status"?: string;
    "subscriptions"?: Array<string>;
    "timeZone"?: string;
    "userId"?: string;
    "id"?: number;
}

export interface Notification {
    "alert"?: any;
    "badge"?: number;
    "category"?: string;
    "collapseKey"?: string;
    "contentAvailable"?: boolean;
    "created"?: Date;
    "delayWhileIdle"?: boolean;
    "deviceToken": string;
    "deviceType": string;
    "expirationInterval"?: number;
    "expirationTime"?: Date;
    "modified"?: Date;
    "scheduledTime"?: Date;
    "sound"?: string;
    "status"?: string;
    "urlArgs"?: Array<string>;
    "id"?: number;
}

export interface Role {
    "id"?: number;
    "name": string;
    "description"?: string;
    "created"?: Date;
    "modified"?: Date;
}

/**
 * Map principals to roles
 */
export interface RoleMapping {
    "id"?: number;
    /**
     * The principal type, such as USER, APPLICATION, ROLE, or user model name in case of multiple user models
     */
    "principalType"?: string;
    "principalId"?: string;
    "roleId"?: number;
}

export interface Transaction {
    "appleReceipt"?: string;
    "googleReceipt"?: TransactionGoogleReceipt;
    "id"?: number;
}

export interface TransactionGoogleReceipt {
    "data"?: any;
    "signature"?: string;
}

export interface User {
    "realm"?: string;
    "username"?: string;
    "email": string;
    "emailVerified"?: boolean;
    "id"?: number;
}



/**
 * AccountApi - fetch parameter creator
 */
export const AccountApiFetchParamCreator = {
    /**
     * 
     * @summary Change a user's password.
     * @param oldPassword 
     * @param newPassword 
     */
    accountChangePassword(params: {  "oldPassword": string; "newPassword": string; }, options?: any): FetchArgs {
        // verify required parameter "oldPassword" is set
        if (params["oldPassword"] == null) {
            throw new Error("Missing required parameter oldPassword when calling accountChangePassword");
        }
        // verify required parameter "newPassword" is set
        if (params["newPassword"] == null) {
            throw new Error("Missing required parameter newPassword when calling accountChangePassword");
        }
        const baseUrl = `/Accounts/change-password`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "oldPassword": params["oldPassword"],
            "newPassword": params["newPassword"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Confirm a user registration with identity verification token.
     * @param uid 
     * @param token 
     * @param redirect 
     */
    accountConfirm(params: {  "uid": string; "token": string; "redirect"?: string; }, options?: any): FetchArgs {
        // verify required parameter "uid" is set
        if (params["uid"] == null) {
            throw new Error("Missing required parameter uid when calling accountConfirm");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            throw new Error("Missing required parameter token when calling accountConfirm");
        }
        const baseUrl = `/Accounts/confirm`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "uid": params["uid"],
            "token": params["token"],
            "redirect": params["redirect"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params: {  "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamGetAccountsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamPostAccountsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountDeleteById");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountExistsGetAccountsidExists");
        }
        const baseUrl = `/Accounts/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountExistsHeadAccountsid");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountFindById");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Login a user with username/email and password.
     * @param credentials 
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params: {  "credentials": any; "include"?: string; }, options?: any): FetchArgs {
        // verify required parameter "credentials" is set
        if (params["credentials"] == null) {
            throw new Error("Missing required parameter credentials when calling accountLogin");
        }
        const baseUrl = `/Accounts/login`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "include": params["include"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["credentials"]) {
            fetchOptions.body = JSON.stringify(params["credentials"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Logout a user with access token.
     */
    accountLogout(options?: any): FetchArgs {
        const baseUrl = `/Accounts/logout`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params: {  "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCountAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts activeLogs of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountActiveLogs(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCountActiveLogs");
        }
        const baseUrl = `/Accounts/{id}/activeLogs/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts roles of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountRoles(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCountRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateAccessTokens(params: {  "id": string; "data"?: AccountToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCreateAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in activeLogs of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateActiveLogs(params: {  "id": string; "data"?: ActiveLog; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCreateActiveLogs");
        }
        const baseUrl = `/Accounts/{id}/activeLogs`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in roles of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateRoles(params: {  "id": string; "data"?: Role; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCreateRoles");
        }
        const baseUrl = `/Accounts/{id}/roles`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDeleteAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all activeLogs of this model.
     * @param id Account id
     */
    accountPrototypeDeleteActiveLogs(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDeleteActiveLogs");
        }
        const baseUrl = `/Accounts/{id}/activeLogs`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all roles of this model.
     * @param id Account id
     */
    accountPrototypeDeleteRoles(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDeleteRoles");
        }
        const baseUrl = `/Accounts/{id}/roles`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDestroyByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeDestroyByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for activeLogs.
     * @param id Account id
     * @param fk Foreign key for activeLogs
     */
    accountPrototypeDestroyByIdActiveLogs(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDestroyByIdActiveLogs");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeDestroyByIdActiveLogs");
        }
        const baseUrl = `/Accounts/{id}/activeLogs/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeDestroyByIdRoles(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDestroyByIdRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeDestroyByIdRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check the existence of roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeExistsRoles(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeExistsRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeExistsRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeFindByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeFindByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for activeLogs.
     * @param id Account id
     * @param fk Foreign key for activeLogs
     */
    accountPrototypeFindByIdActiveLogs(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeFindByIdActiveLogs");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeFindByIdActiveLogs");
        }
        const baseUrl = `/Accounts/{id}/activeLogs/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeFindByIdRoles(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeFindByIdRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeFindByIdRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries activeLogs of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetActiveLogs(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetActiveLogs");
        }
        const baseUrl = `/Accounts/{id}/activeLogs`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation manager.
     * @param id Account id
     * @param refresh 
     */
    accountPrototypeGetManager(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetManager");
        }
        const baseUrl = `/Accounts/{id}/manager`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries roles of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetRoles(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetRoles");
        }
        const baseUrl = `/Accounts/{id}/roles`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Add a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data 
     */
    accountPrototypeLinkRoles(params: {  "id": string; "fk": string; "data"?: RoleMapping; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeLinkRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeLinkRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params: {  "id": string; "data"?: Account; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypePatchAttributes");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Remove the roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeUnlinkRoles(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUnlinkRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUnlinkRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    accountPrototypeUpdateByIdAccessTokens(params: {  "id": string; "fk": string; "data"?: AccountToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUpdateByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUpdateByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for activeLogs.
     * @param id Account id
     * @param fk Foreign key for activeLogs
     * @param data 
     */
    accountPrototypeUpdateByIdActiveLogs(params: {  "id": string; "fk": string; "data"?: ActiveLog; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUpdateByIdActiveLogs");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUpdateByIdActiveLogs");
        }
        const baseUrl = `/Accounts/{id}/activeLogs/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data 
     */
    accountPrototypeUpdateByIdRoles(params: {  "id": string; "fk": string; "data"?: Role; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUpdateByIdRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUpdateByIdRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeVerify");
        }
        const baseUrl = `/Accounts/{id}/verify`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params: {  "id": string; "data"?: Account; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountReplaceByIdPostAccountsidReplace");
        }
        const baseUrl = `/Accounts/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params: {  "id": string; "data"?: Account; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountReplaceByIdPutAccountsid");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params: {  "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params: {  "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Reset password for a user with email.
     * @param options 
     */
    accountResetPassword(params: {  "options": any; }, options?: any): FetchArgs {
        // verify required parameter "options" is set
        if (params["options"] == null) {
            throw new Error("Missing required parameter options when calling accountResetPassword");
        }
        const baseUrl = `/Accounts/reset`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["options"]) {
            fetchOptions.body = JSON.stringify(params["options"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Reset user's password via a password-reset token.
     * @param newPassword 
     */
    accountSetPassword(params: {  "newPassword": string; }, options?: any): FetchArgs {
        // verify required parameter "newPassword" is set
        if (params["newPassword"] == null) {
            throw new Error("Missing required parameter newPassword when calling accountSetPassword");
        }
        const baseUrl = `/Accounts/reset-password`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "newPassword": params["newPassword"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params: {  "where"?: string; "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params: {  "where"?: string; "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AccountApi - functional programming interface
 */
export const AccountApiFp = {
    /**
     * 
     * @summary Change a user's password.
     * @param oldPassword 
     * @param newPassword 
     */
    accountChangePassword(params: { "oldPassword": string; "newPassword": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountChangePassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Confirm a user registration with identity verification token.
     * @param uid 
     * @param token 
     * @param redirect 
     */
    accountConfirm(params: { "uid": string; "token": string; "redirect"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountConfirm(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = AccountApiFetchParamCreator.accountCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params: { "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamGetAccountsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountCreateChangeStreamGetAccountsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamPostAccountsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountCreateChangeStreamPostAccountsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = AccountApiFetchParamCreator.accountExistsGetAccountsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = AccountApiFetchParamCreator.accountExistsHeadAccountsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Account>> {
        const fetchArgs = AccountApiFetchParamCreator.accountFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Login a user with username/email and password.
     * @param credentials 
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params: { "credentials": any; "include"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountLogin(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Logout a user with access token.
     */
    accountLogout(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountLogout(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params: { "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCountAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts activeLogs of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountActiveLogs(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCountActiveLogs(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts roles of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountRoles(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCountRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateAccessTokens(params: { "id": string; "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCreateAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in activeLogs of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateActiveLogs(params: { "id": string; "data"?: ActiveLog;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActiveLog> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCreateActiveLogs(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in roles of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateRoles(params: { "id": string; "data"?: Role;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCreateRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDeleteAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all activeLogs of this model.
     * @param id Account id
     */
    accountPrototypeDeleteActiveLogs(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDeleteActiveLogs(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all roles of this model.
     * @param id Account id
     */
    accountPrototypeDeleteRoles(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDeleteRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDestroyByIdAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for activeLogs.
     * @param id Account id
     * @param fk Foreign key for activeLogs
     */
    accountPrototypeDestroyByIdActiveLogs(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDestroyByIdActiveLogs(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeDestroyByIdRoles(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDestroyByIdRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check the existence of roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeExistsRoles(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeExistsRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeFindByIdAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for activeLogs.
     * @param id Account id
     * @param fk Foreign key for activeLogs
     */
    accountPrototypeFindByIdActiveLogs(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActiveLog> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeFindByIdActiveLogs(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeFindByIdRoles(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeFindByIdRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetAccessTokens(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AccountToken>> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries activeLogs of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetActiveLogs(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ActiveLog>> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetActiveLogs(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation manager.
     * @param id Account id
     * @param refresh 
     */
    accountPrototypeGetManager(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetManager(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries roles of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetRoles(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Role>> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Add a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data 
     */
    accountPrototypeLinkRoles(params: { "id": string; "fk": string; "data"?: RoleMapping;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeLinkRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params: { "id": string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Remove the roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeUnlinkRoles(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUnlinkRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    accountPrototypeUpdateByIdAccessTokens(params: { "id": string; "fk": string; "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUpdateByIdAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for activeLogs.
     * @param id Account id
     * @param fk Foreign key for activeLogs
     * @param data 
     */
    accountPrototypeUpdateByIdActiveLogs(params: { "id": string; "fk": string; "data"?: ActiveLog;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActiveLog> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUpdateByIdActiveLogs(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data 
     */
    accountPrototypeUpdateByIdRoles(params: { "id": string; "fk": string; "data"?: Role;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUpdateByIdRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeVerify(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params: { "id": string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountReplaceByIdPostAccountsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params: { "id": string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountReplaceByIdPutAccountsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params: { "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params: { "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountReplaceOrCreatePutAccounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Reset password for a user with email.
     * @param options 
     */
    accountResetPassword(params: { "options": any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountResetPassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Reset user's password via a password-reset token.
     * @param newPassword 
     */
    accountSetPassword(params: { "newPassword": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountSetPassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params: { "where"?: string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = AccountApiFetchParamCreator.accountUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params: { "where"?: string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AccountApi - object-oriented interface
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @summary Change a user's password.
     * @param oldPassword 
     * @param newPassword 
     */
    accountChangePassword(params: {  "oldPassword": string; "newPassword": string; }, options?: any) {
        return AccountApiFp.accountChangePassword(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Confirm a user registration with identity verification token.
     * @param uid 
     * @param token 
     * @param redirect 
     */
    accountConfirm(params: {  "uid": string; "token": string; "redirect"?: string; }, options?: any) {
        return AccountApiFp.accountConfirm(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params: {  "where"?: string; }, options?: any) {
        return AccountApiFp.accountCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params: {  "data"?: Account; }, options?: any) {
        return AccountApiFp.accountCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamGetAccountsChangeStream(params: {  "options"?: string; }, options?: any) {
        return AccountApiFp.accountCreateChangeStreamGetAccountsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamPostAccountsChangeStream(params: {  "options"?: string; }, options?: any) {
        return AccountApiFp.accountCreateChangeStreamPostAccountsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountExistsGetAccountsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountExistsHeadAccountsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params: {  "filter"?: string; }, options?: any) {
        return AccountApiFp.accountFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return AccountApiFp.accountFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params: {  "filter"?: string; }, options?: any) {
        return AccountApiFp.accountFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Login a user with username/email and password.
     * @param credentials 
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params: {  "credentials": any; "include"?: string; }, options?: any) {
        return AccountApiFp.accountLogin(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Logout a user with access token.
     */
    accountLogout(options?: any) {
        return AccountApiFp.accountLogout(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params: {  "data"?: Account; }, options?: any) {
        return AccountApiFp.accountPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any) {
        return AccountApiFp.accountPrototypeCountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts activeLogs of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountActiveLogs(params: {  "id": string; "where"?: string; }, options?: any) {
        return AccountApiFp.accountPrototypeCountActiveLogs(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts roles of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountRoles(params: {  "id": string; "where"?: string; }, options?: any) {
        return AccountApiFp.accountPrototypeCountRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateAccessTokens(params: {  "id": string; "data"?: AccountToken; }, options?: any) {
        return AccountApiFp.accountPrototypeCreateAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in activeLogs of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateActiveLogs(params: {  "id": string; "data"?: ActiveLog; }, options?: any) {
        return AccountApiFp.accountPrototypeCreateActiveLogs(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in roles of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateRoles(params: {  "id": string; "data"?: Role; }, options?: any) {
        return AccountApiFp.accountPrototypeCreateRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountPrototypeDeleteAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all activeLogs of this model.
     * @param id Account id
     */
    accountPrototypeDeleteActiveLogs(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountPrototypeDeleteActiveLogs(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all roles of this model.
     * @param id Account id
     */
    accountPrototypeDeleteRoles(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountPrototypeDeleteRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeDestroyByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for activeLogs.
     * @param id Account id
     * @param fk Foreign key for activeLogs
     */
    accountPrototypeDestroyByIdActiveLogs(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeDestroyByIdActiveLogs(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeDestroyByIdRoles(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeDestroyByIdRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check the existence of roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeExistsRoles(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeExistsRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeFindByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for activeLogs.
     * @param id Account id
     * @param fk Foreign key for activeLogs
     */
    accountPrototypeFindByIdActiveLogs(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeFindByIdActiveLogs(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeFindByIdRoles(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeFindByIdRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any) {
        return AccountApiFp.accountPrototypeGetAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries activeLogs of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetActiveLogs(params: {  "id": string; "filter"?: string; }, options?: any) {
        return AccountApiFp.accountPrototypeGetActiveLogs(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation manager.
     * @param id Account id
     * @param refresh 
     */
    accountPrototypeGetManager(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return AccountApiFp.accountPrototypeGetManager(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries roles of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetRoles(params: {  "id": string; "filter"?: string; }, options?: any) {
        return AccountApiFp.accountPrototypeGetRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Add a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data 
     */
    accountPrototypeLinkRoles(params: {  "id": string; "fk": string; "data"?: RoleMapping; }, options?: any) {
        return AccountApiFp.accountPrototypeLinkRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params: {  "id": string; "data"?: Account; }, options?: any) {
        return AccountApiFp.accountPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Remove the roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeUnlinkRoles(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeUnlinkRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    accountPrototypeUpdateByIdAccessTokens(params: {  "id": string; "fk": string; "data"?: AccountToken; }, options?: any) {
        return AccountApiFp.accountPrototypeUpdateByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for activeLogs.
     * @param id Account id
     * @param fk Foreign key for activeLogs
     * @param data 
     */
    accountPrototypeUpdateByIdActiveLogs(params: {  "id": string; "fk": string; "data"?: ActiveLog; }, options?: any) {
        return AccountApiFp.accountPrototypeUpdateByIdActiveLogs(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data 
     */
    accountPrototypeUpdateByIdRoles(params: {  "id": string; "fk": string; "data"?: Role; }, options?: any) {
        return AccountApiFp.accountPrototypeUpdateByIdRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountPrototypeVerify(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params: {  "id": string; "data"?: Account; }, options?: any) {
        return AccountApiFp.accountReplaceByIdPostAccountsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params: {  "id": string; "data"?: Account; }, options?: any) {
        return AccountApiFp.accountReplaceByIdPutAccountsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params: {  "data"?: Account; }, options?: any) {
        return AccountApiFp.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params: {  "data"?: Account; }, options?: any) {
        return AccountApiFp.accountReplaceOrCreatePutAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Reset password for a user with email.
     * @param options 
     */
    accountResetPassword(params: {  "options": any; }, options?: any) {
        return AccountApiFp.accountResetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Reset user's password via a password-reset token.
     * @param newPassword 
     */
    accountSetPassword(params: {  "newPassword": string; }, options?: any) {
        return AccountApiFp.accountSetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params: {  "where"?: string; "data"?: Account; }, options?: any) {
        return AccountApiFp.accountUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params: {  "where"?: string; "data"?: Account; }, options?: any) {
        return AccountApiFp.accountUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AccountApi - factory interface
 */
export const AccountApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Change a user's password.
         * @param oldPassword 
         * @param newPassword 
         */
        accountChangePassword(params: {  "oldPassword": string; "newPassword": string; }, options?: any) {
            return AccountApiFp.accountChangePassword(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Confirm a user registration with identity verification token.
         * @param uid 
         * @param token 
         * @param redirect 
         */
        accountConfirm(params: {  "uid": string; "token": string; "redirect"?: string; }, options?: any) {
            return AccountApiFp.accountConfirm(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        accountCount(params: {  "where"?: string; }, options?: any) {
            return AccountApiFp.accountCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        accountCreate(params: {  "data"?: Account; }, options?: any) {
            return AccountApiFp.accountCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        accountCreateChangeStreamGetAccountsChangeStream(params: {  "options"?: string; }, options?: any) {
            return AccountApiFp.accountCreateChangeStreamGetAccountsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        accountCreateChangeStreamPostAccountsChangeStream(params: {  "options"?: string; }, options?: any) {
            return AccountApiFp.accountCreateChangeStreamPostAccountsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        accountDeleteById(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountExistsGetAccountsidExists(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountExistsGetAccountsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountExistsHeadAccountsid(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountExistsHeadAccountsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountFind(params: {  "filter"?: string; }, options?: any) {
            return AccountApiFp.accountFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        accountFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return AccountApiFp.accountFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountFindOne(params: {  "filter"?: string; }, options?: any) {
            return AccountApiFp.accountFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Login a user with username/email and password.
         * @param credentials 
         * @param include Related objects to include in the response. See the description of return value for more details.
         */
        accountLogin(params: {  "credentials": any; "include"?: string; }, options?: any) {
            return AccountApiFp.accountLogin(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Logout a user with access token.
         */
        accountLogout(options?: any) {
            return AccountApiFp.accountLogout(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountPatchOrCreate(params: {  "data"?: Account; }, options?: any) {
            return AccountApiFp.accountPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts accessTokens of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any) {
            return AccountApiFp.accountPrototypeCountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts activeLogs of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountActiveLogs(params: {  "id": string; "where"?: string; }, options?: any) {
            return AccountApiFp.accountPrototypeCountActiveLogs(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts roles of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountRoles(params: {  "id": string; "where"?: string; }, options?: any) {
            return AccountApiFp.accountPrototypeCountRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in accessTokens of this model.
         * @param id Account id
         * @param data 
         */
        accountPrototypeCreateAccessTokens(params: {  "id": string; "data"?: AccountToken; }, options?: any) {
            return AccountApiFp.accountPrototypeCreateAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in activeLogs of this model.
         * @param id Account id
         * @param data 
         */
        accountPrototypeCreateActiveLogs(params: {  "id": string; "data"?: ActiveLog; }, options?: any) {
            return AccountApiFp.accountPrototypeCreateActiveLogs(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in roles of this model.
         * @param id Account id
         * @param data 
         */
        accountPrototypeCreateRoles(params: {  "id": string; "data"?: Role; }, options?: any) {
            return AccountApiFp.accountPrototypeCreateRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all accessTokens of this model.
         * @param id Account id
         */
        accountPrototypeDeleteAccessTokens(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountPrototypeDeleteAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all activeLogs of this model.
         * @param id Account id
         */
        accountPrototypeDeleteActiveLogs(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountPrototypeDeleteActiveLogs(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all roles of this model.
         * @param id Account id
         */
        accountPrototypeDeleteRoles(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountPrototypeDeleteRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         */
        accountPrototypeDestroyByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeDestroyByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for activeLogs.
         * @param id Account id
         * @param fk Foreign key for activeLogs
         */
        accountPrototypeDestroyByIdActiveLogs(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeDestroyByIdActiveLogs(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeDestroyByIdRoles(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeDestroyByIdRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check the existence of roles relation to an item by id.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeExistsRoles(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeExistsRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         */
        accountPrototypeFindByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeFindByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for activeLogs.
         * @param id Account id
         * @param fk Foreign key for activeLogs
         */
        accountPrototypeFindByIdActiveLogs(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeFindByIdActiveLogs(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeFindByIdRoles(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeFindByIdRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries accessTokens of Account.
         * @param id Account id
         * @param filter 
         */
        accountPrototypeGetAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any) {
            return AccountApiFp.accountPrototypeGetAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries activeLogs of Account.
         * @param id Account id
         * @param filter 
         */
        accountPrototypeGetActiveLogs(params: {  "id": string; "filter"?: string; }, options?: any) {
            return AccountApiFp.accountPrototypeGetActiveLogs(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation manager.
         * @param id Account id
         * @param refresh 
         */
        accountPrototypeGetManager(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return AccountApiFp.accountPrototypeGetManager(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries roles of Account.
         * @param id Account id
         * @param filter 
         */
        accountPrototypeGetRoles(params: {  "id": string; "filter"?: string; }, options?: any) {
            return AccountApiFp.accountPrototypeGetRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         * @param data 
         */
        accountPrototypeLinkRoles(params: {  "id": string; "fk": string; "data"?: RoleMapping; }, options?: any) {
            return AccountApiFp.accountPrototypeLinkRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Account id
         * @param data An object of model property name/value pairs
         */
        accountPrototypePatchAttributes(params: {  "id": string; "data"?: Account; }, options?: any) {
            return AccountApiFp.accountPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the roles relation to an item by id.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeUnlinkRoles(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeUnlinkRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         * @param data 
         */
        accountPrototypeUpdateByIdAccessTokens(params: {  "id": string; "fk": string; "data"?: AccountToken; }, options?: any) {
            return AccountApiFp.accountPrototypeUpdateByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for activeLogs.
         * @param id Account id
         * @param fk Foreign key for activeLogs
         * @param data 
         */
        accountPrototypeUpdateByIdActiveLogs(params: {  "id": string; "fk": string; "data"?: ActiveLog; }, options?: any) {
            return AccountApiFp.accountPrototypeUpdateByIdActiveLogs(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         * @param data 
         */
        accountPrototypeUpdateByIdRoles(params: {  "id": string; "fk": string; "data"?: Role; }, options?: any) {
            return AccountApiFp.accountPrototypeUpdateByIdRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Trigger user's identity verification with configured verifyOptions
         * @param id Account id
         */
        accountPrototypeVerify(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountPrototypeVerify(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountReplaceByIdPostAccountsidReplace(params: {  "id": string; "data"?: Account; }, options?: any) {
            return AccountApiFp.accountReplaceByIdPostAccountsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountReplaceByIdPutAccountsid(params: {  "id": string; "data"?: Account; }, options?: any) {
            return AccountApiFp.accountReplaceByIdPutAccountsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountReplaceOrCreatePostAccountsReplaceOrCreate(params: {  "data"?: Account; }, options?: any) {
            return AccountApiFp.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountReplaceOrCreatePutAccounts(params: {  "data"?: Account; }, options?: any) {
            return AccountApiFp.accountReplaceOrCreatePutAccounts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reset password for a user with email.
         * @param options 
         */
        accountResetPassword(params: {  "options": any; }, options?: any) {
            return AccountApiFp.accountResetPassword(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reset user's password via a password-reset token.
         * @param newPassword 
         */
        accountSetPassword(params: {  "newPassword": string; }, options?: any) {
            return AccountApiFp.accountSetPassword(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountUpdateAll(params: {  "where"?: string; "data"?: Account; }, options?: any) {
            return AccountApiFp.accountUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountUpsertWithWhere(params: {  "where"?: string; "data"?: Account; }, options?: any) {
            return AccountApiFp.accountUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * AccountTokenApi - fetch parameter creator
 */
export const AccountTokenApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountTokenCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountTokenCreate(params: {  "data"?: AccountToken; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountTokenCreateChangeStreamGetAccountTokensChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountTokenCreateChangeStreamPostAccountTokensChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountTokenDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenDeleteById");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsGetAccountTokensidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenExistsGetAccountTokensidExists");
        }
        const baseUrl = `/AccountTokens/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsHeadAccountTokensid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenExistsHeadAccountTokensid");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountTokenFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenFindById");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenPatchOrCreate(params: {  "data"?: AccountToken; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id AccountToken id
     * @param refresh 
     */
    accountTokenPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenPrototypeGetAccount");
        }
        const baseUrl = `/AccountTokens/{id}/account`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation user.
     * @param id AccountToken id
     * @param refresh 
     */
    accountTokenPrototypeGetUser(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenPrototypeGetUser");
        }
        const baseUrl = `/AccountTokens/{id}/user`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountToken id
     * @param data An object of model property name/value pairs
     */
    accountTokenPrototypePatchAttributes(params: {  "id": string; "data"?: AccountToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenPrototypePatchAttributes");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPostAccountTokensidReplace(params: {  "id": string; "data"?: AccountToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenReplaceByIdPostAccountTokensidReplace");
        }
        const baseUrl = `/AccountTokens/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPutAccountTokensid(params: {  "id": string; "data"?: AccountToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenReplaceByIdPutAccountTokensid");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params: {  "data"?: AccountToken; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePutAccountTokens(params: {  "data"?: AccountToken; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpdateAll(params: {  "where"?: string; "data"?: AccountToken; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpsertWithWhere(params: {  "where"?: string; "data"?: AccountToken; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AccountTokenApi - functional programming interface
 */
export const AccountTokenApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountTokenCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountTokenCreate(params: { "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountTokenCreateChangeStreamGetAccountTokensChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountTokenCreateChangeStreamPostAccountTokensChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountTokenDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsGetAccountTokensidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenExistsGetAccountTokensidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsHeadAccountTokensid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenExistsHeadAccountTokensid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AccountToken>> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountTokenFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenPatchOrCreate(params: { "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id AccountToken id
     * @param refresh 
     */
    accountTokenPrototypeGetAccount(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenPrototypeGetAccount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation user.
     * @param id AccountToken id
     * @param refresh 
     */
    accountTokenPrototypeGetUser(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenPrototypeGetUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountToken id
     * @param data An object of model property name/value pairs
     */
    accountTokenPrototypePatchAttributes(params: { "id": string; "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPostAccountTokensidReplace(params: { "id": string; "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenReplaceByIdPostAccountTokensidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPutAccountTokensid(params: { "id": string; "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenReplaceByIdPutAccountTokensid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params: { "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePutAccountTokens(params: { "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenReplaceOrCreatePutAccountTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpdateAll(params: { "where"?: string; "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpsertWithWhere(params: { "where"?: string; "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AccountTokenApi - object-oriented interface
 */
export class AccountTokenApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountTokenCount(params: {  "where"?: string; }, options?: any) {
        return AccountTokenApiFp.accountTokenCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountTokenCreate(params: {  "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountTokenCreateChangeStreamGetAccountTokensChangeStream(params: {  "options"?: string; }, options?: any) {
        return AccountTokenApiFp.accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountTokenCreateChangeStreamPostAccountTokensChangeStream(params: {  "options"?: string; }, options?: any) {
        return AccountTokenApiFp.accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountTokenDeleteById(params: {  "id": string; }, options?: any) {
        return AccountTokenApiFp.accountTokenDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsGetAccountTokensidExists(params: {  "id": string; }, options?: any) {
        return AccountTokenApiFp.accountTokenExistsGetAccountTokensidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsHeadAccountTokensid(params: {  "id": string; }, options?: any) {
        return AccountTokenApiFp.accountTokenExistsHeadAccountTokensid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFind(params: {  "filter"?: string; }, options?: any) {
        return AccountTokenApiFp.accountTokenFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountTokenFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return AccountTokenApiFp.accountTokenFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFindOne(params: {  "filter"?: string; }, options?: any) {
        return AccountTokenApiFp.accountTokenFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenPatchOrCreate(params: {  "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id AccountToken id
     * @param refresh 
     */
    accountTokenPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return AccountTokenApiFp.accountTokenPrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation user.
     * @param id AccountToken id
     * @param refresh 
     */
    accountTokenPrototypeGetUser(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return AccountTokenApiFp.accountTokenPrototypeGetUser(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountToken id
     * @param data An object of model property name/value pairs
     */
    accountTokenPrototypePatchAttributes(params: {  "id": string; "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPostAccountTokensidReplace(params: {  "id": string; "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenReplaceByIdPostAccountTokensidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPutAccountTokensid(params: {  "id": string; "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenReplaceByIdPutAccountTokensid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params: {  "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePutAccountTokens(params: {  "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenReplaceOrCreatePutAccountTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpdateAll(params: {  "where"?: string; "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpsertWithWhere(params: {  "where"?: string; "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AccountTokenApi - factory interface
 */
export const AccountTokenApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        accountTokenCount(params: {  "where"?: string; }, options?: any) {
            return AccountTokenApiFp.accountTokenCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        accountTokenCreate(params: {  "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        accountTokenCreateChangeStreamGetAccountTokensChangeStream(params: {  "options"?: string; }, options?: any) {
            return AccountTokenApiFp.accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        accountTokenCreateChangeStreamPostAccountTokensChangeStream(params: {  "options"?: string; }, options?: any) {
            return AccountTokenApiFp.accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        accountTokenDeleteById(params: {  "id": string; }, options?: any) {
            return AccountTokenApiFp.accountTokenDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountTokenExistsGetAccountTokensidExists(params: {  "id": string; }, options?: any) {
            return AccountTokenApiFp.accountTokenExistsGetAccountTokensidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountTokenExistsHeadAccountTokensid(params: {  "id": string; }, options?: any) {
            return AccountTokenApiFp.accountTokenExistsHeadAccountTokensid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountTokenFind(params: {  "filter"?: string; }, options?: any) {
            return AccountTokenApiFp.accountTokenFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        accountTokenFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return AccountTokenApiFp.accountTokenFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountTokenFindOne(params: {  "filter"?: string; }, options?: any) {
            return AccountTokenApiFp.accountTokenFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountTokenPatchOrCreate(params: {  "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation account.
         * @param id AccountToken id
         * @param refresh 
         */
        accountTokenPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return AccountTokenApiFp.accountTokenPrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation user.
         * @param id AccountToken id
         * @param refresh 
         */
        accountTokenPrototypeGetUser(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return AccountTokenApiFp.accountTokenPrototypeGetUser(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id AccountToken id
         * @param data An object of model property name/value pairs
         */
        accountTokenPrototypePatchAttributes(params: {  "id": string; "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountTokenReplaceByIdPostAccountTokensidReplace(params: {  "id": string; "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenReplaceByIdPostAccountTokensidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountTokenReplaceByIdPutAccountTokensid(params: {  "id": string; "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenReplaceByIdPutAccountTokensid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params: {  "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountTokenReplaceOrCreatePutAccountTokens(params: {  "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenReplaceOrCreatePutAccountTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountTokenUpdateAll(params: {  "where"?: string; "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountTokenUpsertWithWhere(params: {  "where"?: string; "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * ActiveLogApi - fetch parameter creator
 */
export const ActiveLogApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    activeLogCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/ActiveLogs/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    activeLogCreate(params: {  "data"?: ActiveLog; }, options?: any): FetchArgs {
        const baseUrl = `/ActiveLogs`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    activeLogCreateChangeStreamGetActiveLogsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/ActiveLogs/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    activeLogCreateChangeStreamPostActiveLogsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/ActiveLogs/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    activeLogDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling activeLogDeleteById");
        }
        const baseUrl = `/ActiveLogs/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    activeLogExistsGetActiveLogsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling activeLogExistsGetActiveLogsidExists");
        }
        const baseUrl = `/ActiveLogs/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    activeLogExistsHeadActiveLogsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling activeLogExistsHeadActiveLogsid");
        }
        const baseUrl = `/ActiveLogs/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    activeLogFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/ActiveLogs`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    activeLogFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling activeLogFindById");
        }
        const baseUrl = `/ActiveLogs/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    activeLogFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/ActiveLogs/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    activeLogPatchOrCreate(params: {  "data"?: ActiveLog; }, options?: any): FetchArgs {
        const baseUrl = `/ActiveLogs`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id ActiveLog id
     * @param refresh 
     */
    activeLogPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling activeLogPrototypeGetAccount");
        }
        const baseUrl = `/ActiveLogs/{id}/account`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id ActiveLog id
     * @param data An object of model property name/value pairs
     */
    activeLogPrototypePatchAttributes(params: {  "id": string; "data"?: ActiveLog; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling activeLogPrototypePatchAttributes");
        }
        const baseUrl = `/ActiveLogs/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    activeLogReplaceByIdPostActiveLogsidReplace(params: {  "id": string; "data"?: ActiveLog; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling activeLogReplaceByIdPostActiveLogsidReplace");
        }
        const baseUrl = `/ActiveLogs/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    activeLogReplaceByIdPutActiveLogsid(params: {  "id": string; "data"?: ActiveLog; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling activeLogReplaceByIdPutActiveLogsid");
        }
        const baseUrl = `/ActiveLogs/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    activeLogReplaceOrCreatePostActiveLogsReplaceOrCreate(params: {  "data"?: ActiveLog; }, options?: any): FetchArgs {
        const baseUrl = `/ActiveLogs/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    activeLogReplaceOrCreatePutActiveLogs(params: {  "data"?: ActiveLog; }, options?: any): FetchArgs {
        const baseUrl = `/ActiveLogs`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    activeLogUpdateAll(params: {  "where"?: string; "data"?: ActiveLog; }, options?: any): FetchArgs {
        const baseUrl = `/ActiveLogs/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    activeLogUpsertWithWhere(params: {  "where"?: string; "data"?: ActiveLog; }, options?: any): FetchArgs {
        const baseUrl = `/ActiveLogs/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ActiveLogApi - functional programming interface
 */
export const ActiveLogApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    activeLogCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = ActiveLogApiFetchParamCreator.activeLogCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    activeLogCreate(params: { "data"?: ActiveLog;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActiveLog> {
        const fetchArgs = ActiveLogApiFetchParamCreator.activeLogCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    activeLogCreateChangeStreamGetActiveLogsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ActiveLogApiFetchParamCreator.activeLogCreateChangeStreamGetActiveLogsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    activeLogCreateChangeStreamPostActiveLogsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ActiveLogApiFetchParamCreator.activeLogCreateChangeStreamPostActiveLogsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    activeLogDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ActiveLogApiFetchParamCreator.activeLogDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    activeLogExistsGetActiveLogsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = ActiveLogApiFetchParamCreator.activeLogExistsGetActiveLogsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    activeLogExistsHeadActiveLogsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = ActiveLogApiFetchParamCreator.activeLogExistsHeadActiveLogsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    activeLogFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ActiveLog>> {
        const fetchArgs = ActiveLogApiFetchParamCreator.activeLogFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    activeLogFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActiveLog> {
        const fetchArgs = ActiveLogApiFetchParamCreator.activeLogFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    activeLogFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActiveLog> {
        const fetchArgs = ActiveLogApiFetchParamCreator.activeLogFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    activeLogPatchOrCreate(params: { "data"?: ActiveLog;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActiveLog> {
        const fetchArgs = ActiveLogApiFetchParamCreator.activeLogPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id ActiveLog id
     * @param refresh 
     */
    activeLogPrototypeGetAccount(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = ActiveLogApiFetchParamCreator.activeLogPrototypeGetAccount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id ActiveLog id
     * @param data An object of model property name/value pairs
     */
    activeLogPrototypePatchAttributes(params: { "id": string; "data"?: ActiveLog;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActiveLog> {
        const fetchArgs = ActiveLogApiFetchParamCreator.activeLogPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    activeLogReplaceByIdPostActiveLogsidReplace(params: { "id": string; "data"?: ActiveLog;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActiveLog> {
        const fetchArgs = ActiveLogApiFetchParamCreator.activeLogReplaceByIdPostActiveLogsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    activeLogReplaceByIdPutActiveLogsid(params: { "id": string; "data"?: ActiveLog;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActiveLog> {
        const fetchArgs = ActiveLogApiFetchParamCreator.activeLogReplaceByIdPutActiveLogsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    activeLogReplaceOrCreatePostActiveLogsReplaceOrCreate(params: { "data"?: ActiveLog;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActiveLog> {
        const fetchArgs = ActiveLogApiFetchParamCreator.activeLogReplaceOrCreatePostActiveLogsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    activeLogReplaceOrCreatePutActiveLogs(params: { "data"?: ActiveLog;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActiveLog> {
        const fetchArgs = ActiveLogApiFetchParamCreator.activeLogReplaceOrCreatePutActiveLogs(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    activeLogUpdateAll(params: { "where"?: string; "data"?: ActiveLog;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = ActiveLogApiFetchParamCreator.activeLogUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    activeLogUpsertWithWhere(params: { "where"?: string; "data"?: ActiveLog;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActiveLog> {
        const fetchArgs = ActiveLogApiFetchParamCreator.activeLogUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ActiveLogApi - object-oriented interface
 */
export class ActiveLogApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    activeLogCount(params: {  "where"?: string; }, options?: any) {
        return ActiveLogApiFp.activeLogCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    activeLogCreate(params: {  "data"?: ActiveLog; }, options?: any) {
        return ActiveLogApiFp.activeLogCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    activeLogCreateChangeStreamGetActiveLogsChangeStream(params: {  "options"?: string; }, options?: any) {
        return ActiveLogApiFp.activeLogCreateChangeStreamGetActiveLogsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    activeLogCreateChangeStreamPostActiveLogsChangeStream(params: {  "options"?: string; }, options?: any) {
        return ActiveLogApiFp.activeLogCreateChangeStreamPostActiveLogsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    activeLogDeleteById(params: {  "id": string; }, options?: any) {
        return ActiveLogApiFp.activeLogDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    activeLogExistsGetActiveLogsidExists(params: {  "id": string; }, options?: any) {
        return ActiveLogApiFp.activeLogExistsGetActiveLogsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    activeLogExistsHeadActiveLogsid(params: {  "id": string; }, options?: any) {
        return ActiveLogApiFp.activeLogExistsHeadActiveLogsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    activeLogFind(params: {  "filter"?: string; }, options?: any) {
        return ActiveLogApiFp.activeLogFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    activeLogFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return ActiveLogApiFp.activeLogFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    activeLogFindOne(params: {  "filter"?: string; }, options?: any) {
        return ActiveLogApiFp.activeLogFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    activeLogPatchOrCreate(params: {  "data"?: ActiveLog; }, options?: any) {
        return ActiveLogApiFp.activeLogPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id ActiveLog id
     * @param refresh 
     */
    activeLogPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return ActiveLogApiFp.activeLogPrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id ActiveLog id
     * @param data An object of model property name/value pairs
     */
    activeLogPrototypePatchAttributes(params: {  "id": string; "data"?: ActiveLog; }, options?: any) {
        return ActiveLogApiFp.activeLogPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    activeLogReplaceByIdPostActiveLogsidReplace(params: {  "id": string; "data"?: ActiveLog; }, options?: any) {
        return ActiveLogApiFp.activeLogReplaceByIdPostActiveLogsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    activeLogReplaceByIdPutActiveLogsid(params: {  "id": string; "data"?: ActiveLog; }, options?: any) {
        return ActiveLogApiFp.activeLogReplaceByIdPutActiveLogsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    activeLogReplaceOrCreatePostActiveLogsReplaceOrCreate(params: {  "data"?: ActiveLog; }, options?: any) {
        return ActiveLogApiFp.activeLogReplaceOrCreatePostActiveLogsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    activeLogReplaceOrCreatePutActiveLogs(params: {  "data"?: ActiveLog; }, options?: any) {
        return ActiveLogApiFp.activeLogReplaceOrCreatePutActiveLogs(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    activeLogUpdateAll(params: {  "where"?: string; "data"?: ActiveLog; }, options?: any) {
        return ActiveLogApiFp.activeLogUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    activeLogUpsertWithWhere(params: {  "where"?: string; "data"?: ActiveLog; }, options?: any) {
        return ActiveLogApiFp.activeLogUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ActiveLogApi - factory interface
 */
export const ActiveLogApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        activeLogCount(params: {  "where"?: string; }, options?: any) {
            return ActiveLogApiFp.activeLogCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        activeLogCreate(params: {  "data"?: ActiveLog; }, options?: any) {
            return ActiveLogApiFp.activeLogCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        activeLogCreateChangeStreamGetActiveLogsChangeStream(params: {  "options"?: string; }, options?: any) {
            return ActiveLogApiFp.activeLogCreateChangeStreamGetActiveLogsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        activeLogCreateChangeStreamPostActiveLogsChangeStream(params: {  "options"?: string; }, options?: any) {
            return ActiveLogApiFp.activeLogCreateChangeStreamPostActiveLogsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        activeLogDeleteById(params: {  "id": string; }, options?: any) {
            return ActiveLogApiFp.activeLogDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        activeLogExistsGetActiveLogsidExists(params: {  "id": string; }, options?: any) {
            return ActiveLogApiFp.activeLogExistsGetActiveLogsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        activeLogExistsHeadActiveLogsid(params: {  "id": string; }, options?: any) {
            return ActiveLogApiFp.activeLogExistsHeadActiveLogsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        activeLogFind(params: {  "filter"?: string; }, options?: any) {
            return ActiveLogApiFp.activeLogFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        activeLogFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return ActiveLogApiFp.activeLogFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        activeLogFindOne(params: {  "filter"?: string; }, options?: any) {
            return ActiveLogApiFp.activeLogFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        activeLogPatchOrCreate(params: {  "data"?: ActiveLog; }, options?: any) {
            return ActiveLogApiFp.activeLogPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation account.
         * @param id ActiveLog id
         * @param refresh 
         */
        activeLogPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return ActiveLogApiFp.activeLogPrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id ActiveLog id
         * @param data An object of model property name/value pairs
         */
        activeLogPrototypePatchAttributes(params: {  "id": string; "data"?: ActiveLog; }, options?: any) {
            return ActiveLogApiFp.activeLogPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        activeLogReplaceByIdPostActiveLogsidReplace(params: {  "id": string; "data"?: ActiveLog; }, options?: any) {
            return ActiveLogApiFp.activeLogReplaceByIdPostActiveLogsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        activeLogReplaceByIdPutActiveLogsid(params: {  "id": string; "data"?: ActiveLog; }, options?: any) {
            return ActiveLogApiFp.activeLogReplaceByIdPutActiveLogsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        activeLogReplaceOrCreatePostActiveLogsReplaceOrCreate(params: {  "data"?: ActiveLog; }, options?: any) {
            return ActiveLogApiFp.activeLogReplaceOrCreatePostActiveLogsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        activeLogReplaceOrCreatePutActiveLogs(params: {  "data"?: ActiveLog; }, options?: any) {
            return ActiveLogApiFp.activeLogReplaceOrCreatePutActiveLogs(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        activeLogUpdateAll(params: {  "where"?: string; "data"?: ActiveLog; }, options?: any) {
            return ActiveLogApiFp.activeLogUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        activeLogUpsertWithWhere(params: {  "where"?: string; "data"?: ActiveLog; }, options?: any) {
            return ActiveLogApiFp.activeLogUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * ContainerApi - fetch parameter creator
 */
export const ContainerApiFetchParamCreator = {
    /**
     * 
     * @param options 
     */
    containerCreateContainer(params: {  "options"?: any; }, options?: any): FetchArgs {
        const baseUrl = `/Containers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["options"]) {
            fetchOptions.body = JSON.stringify(params["options"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     */
    containerDestroyContainer(params: {  "container": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerDestroyContainer");
        }
        const baseUrl = `/Containers/{container}`
            .replace(`{${"container"}}`, `${ params["container"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerDownload(params: {  "container": string; "file": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerDownload");
        }
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling containerDownload");
        }
        const baseUrl = `/Containers/{container}/download/{file}`
            .replace(`{${"container"}}`, `${ params["container"] }`)
            .replace(`{${"file"}}`, `${ params["file"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     */
    containerGetContainer(params: {  "container": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerGetContainer");
        }
        const baseUrl = `/Containers/{container}`
            .replace(`{${"container"}}`, `${ params["container"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     */
    containerGetContainers(options?: any): FetchArgs {
        const baseUrl = `/Containers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerGetFile(params: {  "container": string; "file": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerGetFile");
        }
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling containerGetFile");
        }
        const baseUrl = `/Containers/{container}/files/{file}`
            .replace(`{${"container"}}`, `${ params["container"] }`)
            .replace(`{${"file"}}`, `${ params["file"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     */
    containerGetFiles(params: {  "container": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerGetFiles");
        }
        const baseUrl = `/Containers/{container}/files`
            .replace(`{${"container"}}`, `${ params["container"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerRemoveFile(params: {  "container": string; "file": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerRemoveFile");
        }
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling containerRemoveFile");
        }
        const baseUrl = `/Containers/{container}/files/{file}`
            .replace(`{${"container"}}`, `${ params["container"] }`)
            .replace(`{${"file"}}`, `${ params["file"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     */
    containerUpload(params: {  "container": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerUpload");
        }
        const baseUrl = `/Containers/{container}/upload`
            .replace(`{${"container"}}`, `${ params["container"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ContainerApi - functional programming interface
 */
export const ContainerApiFp = {
    /**
     * 
     * @param options 
     */
    containerCreateContainer(params: { "options"?: any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContainerApiFetchParamCreator.containerCreateContainer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     */
    containerDestroyContainer(params: { "container": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = ContainerApiFetchParamCreator.containerDestroyContainer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerDownload(params: { "container": string; "file": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContainerApiFetchParamCreator.containerDownload(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     */
    containerGetContainer(params: { "container": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContainerApiFetchParamCreator.containerGetContainer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     */
    containerGetContainers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
        const fetchArgs = ContainerApiFetchParamCreator.containerGetContainers(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerGetFile(params: { "container": string; "file": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContainerApiFetchParamCreator.containerGetFile(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     */
    containerGetFiles(params: { "container": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
        const fetchArgs = ContainerApiFetchParamCreator.containerGetFiles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerRemoveFile(params: { "container": string; "file": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = ContainerApiFetchParamCreator.containerRemoveFile(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     */
    containerUpload(params: { "container": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
        const fetchArgs = ContainerApiFetchParamCreator.containerUpload(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ContainerApi - object-oriented interface
 */
export class ContainerApi extends BaseAPI {
    /**
     * 
     * @param options 
     */
    containerCreateContainer(params: {  "options"?: any; }, options?: any) {
        return ContainerApiFp.containerCreateContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     */
    containerDestroyContainer(params: {  "container": string; }, options?: any) {
        return ContainerApiFp.containerDestroyContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     * @param file 
     */
    containerDownload(params: {  "container": string; "file": string; }, options?: any) {
        return ContainerApiFp.containerDownload(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     */
    containerGetContainer(params: {  "container": string; }, options?: any) {
        return ContainerApiFp.containerGetContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     */
    containerGetContainers(options?: any) {
        return ContainerApiFp.containerGetContainers(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     * @param file 
     */
    containerGetFile(params: {  "container": string; "file": string; }, options?: any) {
        return ContainerApiFp.containerGetFile(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     */
    containerGetFiles(params: {  "container": string; }, options?: any) {
        return ContainerApiFp.containerGetFiles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     * @param file 
     */
    containerRemoveFile(params: {  "container": string; "file": string; }, options?: any) {
        return ContainerApiFp.containerRemoveFile(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     */
    containerUpload(params: {  "container": string; }, options?: any) {
        return ContainerApiFp.containerUpload(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ContainerApi - factory interface
 */
export const ContainerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param options 
         */
        containerCreateContainer(params: {  "options"?: any; }, options?: any) {
            return ContainerApiFp.containerCreateContainer(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         */
        containerDestroyContainer(params: {  "container": string; }, options?: any) {
            return ContainerApiFp.containerDestroyContainer(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         * @param file 
         */
        containerDownload(params: {  "container": string; "file": string; }, options?: any) {
            return ContainerApiFp.containerDownload(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         */
        containerGetContainer(params: {  "container": string; }, options?: any) {
            return ContainerApiFp.containerGetContainer(params, options)(fetch, basePath);
        },
        /**
         * 
         */
        containerGetContainers(options?: any) {
            return ContainerApiFp.containerGetContainers(options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         * @param file 
         */
        containerGetFile(params: {  "container": string; "file": string; }, options?: any) {
            return ContainerApiFp.containerGetFile(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         */
        containerGetFiles(params: {  "container": string; }, options?: any) {
            return ContainerApiFp.containerGetFiles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         * @param file 
         */
        containerRemoveFile(params: {  "container": string; "file": string; }, options?: any) {
            return ContainerApiFp.containerRemoveFile(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         */
        containerUpload(params: {  "container": string; }, options?: any) {
            return ContainerApiFp.containerUpload(params, options)(fetch, basePath);
        },
    };
};


/**
 * ExampleApi - fetch parameter creator
 */
export const ExampleApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    exampleCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Examples/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    exampleCreate(params: {  "data"?: Example; }, options?: any): FetchArgs {
        const baseUrl = `/Examples`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    exampleCreateChangeStreamGetExamplesChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Examples/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    exampleCreateChangeStreamPostExamplesChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Examples/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    exampleDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling exampleDeleteById");
        }
        const baseUrl = `/Examples/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    exampleExistsGetExamplesidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling exampleExistsGetExamplesidExists");
        }
        const baseUrl = `/Examples/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    exampleExistsHeadExamplesid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling exampleExistsHeadExamplesid");
        }
        const baseUrl = `/Examples/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    exampleFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Examples`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    exampleFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling exampleFindById");
        }
        const baseUrl = `/Examples/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    exampleFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Examples/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    examplePatchOrCreate(params: {  "data"?: Example; }, options?: any): FetchArgs {
        const baseUrl = `/Examples`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Buy by in-app purchase
     * @param id Example id
     * @param data Data must be a JSON-encoded string of Transaction model
     */
    examplePrototypeBuyIap(params: {  "id": string; "data"?: Transaction; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling examplePrototypeBuyIap");
        }
        const baseUrl = `/Examples/{id}/buyIap`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Example id
     * @param data An object of model property name/value pairs
     */
    examplePrototypePatchAttributes(params: {  "id": string; "data"?: Example; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling examplePrototypePatchAttributes");
        }
        const baseUrl = `/Examples/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    exampleReplaceByIdPostExamplesidReplace(params: {  "id": string; "data"?: Example; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling exampleReplaceByIdPostExamplesidReplace");
        }
        const baseUrl = `/Examples/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    exampleReplaceByIdPutExamplesid(params: {  "id": string; "data"?: Example; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling exampleReplaceByIdPutExamplesid");
        }
        const baseUrl = `/Examples/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    exampleReplaceOrCreatePostExamplesReplaceOrCreate(params: {  "data"?: Example; }, options?: any): FetchArgs {
        const baseUrl = `/Examples/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    exampleReplaceOrCreatePutExamples(params: {  "data"?: Example; }, options?: any): FetchArgs {
        const baseUrl = `/Examples`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    exampleUpdateAll(params: {  "where"?: string; "data"?: Example; }, options?: any): FetchArgs {
        const baseUrl = `/Examples/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    exampleUpsertWithWhere(params: {  "where"?: string; "data"?: Example; }, options?: any): FetchArgs {
        const baseUrl = `/Examples/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ExampleApi - functional programming interface
 */
export const ExampleApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    exampleCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = ExampleApiFetchParamCreator.exampleCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    exampleCreate(params: { "data"?: Example;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Example> {
        const fetchArgs = ExampleApiFetchParamCreator.exampleCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    exampleCreateChangeStreamGetExamplesChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ExampleApiFetchParamCreator.exampleCreateChangeStreamGetExamplesChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    exampleCreateChangeStreamPostExamplesChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ExampleApiFetchParamCreator.exampleCreateChangeStreamPostExamplesChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    exampleDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ExampleApiFetchParamCreator.exampleDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    exampleExistsGetExamplesidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = ExampleApiFetchParamCreator.exampleExistsGetExamplesidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    exampleExistsHeadExamplesid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = ExampleApiFetchParamCreator.exampleExistsHeadExamplesid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    exampleFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Example>> {
        const fetchArgs = ExampleApiFetchParamCreator.exampleFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    exampleFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Example> {
        const fetchArgs = ExampleApiFetchParamCreator.exampleFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    exampleFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Example> {
        const fetchArgs = ExampleApiFetchParamCreator.exampleFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    examplePatchOrCreate(params: { "data"?: Example;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Example> {
        const fetchArgs = ExampleApiFetchParamCreator.examplePatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Buy by in-app purchase
     * @param id Example id
     * @param data Data must be a JSON-encoded string of Transaction model
     */
    examplePrototypeBuyIap(params: { "id": string; "data"?: Transaction;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
        const fetchArgs = ExampleApiFetchParamCreator.examplePrototypeBuyIap(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Example id
     * @param data An object of model property name/value pairs
     */
    examplePrototypePatchAttributes(params: { "id": string; "data"?: Example;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Example> {
        const fetchArgs = ExampleApiFetchParamCreator.examplePrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    exampleReplaceByIdPostExamplesidReplace(params: { "id": string; "data"?: Example;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Example> {
        const fetchArgs = ExampleApiFetchParamCreator.exampleReplaceByIdPostExamplesidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    exampleReplaceByIdPutExamplesid(params: { "id": string; "data"?: Example;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Example> {
        const fetchArgs = ExampleApiFetchParamCreator.exampleReplaceByIdPutExamplesid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    exampleReplaceOrCreatePostExamplesReplaceOrCreate(params: { "data"?: Example;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Example> {
        const fetchArgs = ExampleApiFetchParamCreator.exampleReplaceOrCreatePostExamplesReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    exampleReplaceOrCreatePutExamples(params: { "data"?: Example;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Example> {
        const fetchArgs = ExampleApiFetchParamCreator.exampleReplaceOrCreatePutExamples(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    exampleUpdateAll(params: { "where"?: string; "data"?: Example;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = ExampleApiFetchParamCreator.exampleUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    exampleUpsertWithWhere(params: { "where"?: string; "data"?: Example;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Example> {
        const fetchArgs = ExampleApiFetchParamCreator.exampleUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ExampleApi - object-oriented interface
 */
export class ExampleApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    exampleCount(params: {  "where"?: string; }, options?: any) {
        return ExampleApiFp.exampleCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    exampleCreate(params: {  "data"?: Example; }, options?: any) {
        return ExampleApiFp.exampleCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    exampleCreateChangeStreamGetExamplesChangeStream(params: {  "options"?: string; }, options?: any) {
        return ExampleApiFp.exampleCreateChangeStreamGetExamplesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    exampleCreateChangeStreamPostExamplesChangeStream(params: {  "options"?: string; }, options?: any) {
        return ExampleApiFp.exampleCreateChangeStreamPostExamplesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    exampleDeleteById(params: {  "id": string; }, options?: any) {
        return ExampleApiFp.exampleDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    exampleExistsGetExamplesidExists(params: {  "id": string; }, options?: any) {
        return ExampleApiFp.exampleExistsGetExamplesidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    exampleExistsHeadExamplesid(params: {  "id": string; }, options?: any) {
        return ExampleApiFp.exampleExistsHeadExamplesid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    exampleFind(params: {  "filter"?: string; }, options?: any) {
        return ExampleApiFp.exampleFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    exampleFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return ExampleApiFp.exampleFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    exampleFindOne(params: {  "filter"?: string; }, options?: any) {
        return ExampleApiFp.exampleFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    examplePatchOrCreate(params: {  "data"?: Example; }, options?: any) {
        return ExampleApiFp.examplePatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Buy by in-app purchase
     * @param id Example id
     * @param data Data must be a JSON-encoded string of Transaction model
     */
    examplePrototypeBuyIap(params: {  "id": string; "data"?: Transaction; }, options?: any) {
        return ExampleApiFp.examplePrototypeBuyIap(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Example id
     * @param data An object of model property name/value pairs
     */
    examplePrototypePatchAttributes(params: {  "id": string; "data"?: Example; }, options?: any) {
        return ExampleApiFp.examplePrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    exampleReplaceByIdPostExamplesidReplace(params: {  "id": string; "data"?: Example; }, options?: any) {
        return ExampleApiFp.exampleReplaceByIdPostExamplesidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    exampleReplaceByIdPutExamplesid(params: {  "id": string; "data"?: Example; }, options?: any) {
        return ExampleApiFp.exampleReplaceByIdPutExamplesid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    exampleReplaceOrCreatePostExamplesReplaceOrCreate(params: {  "data"?: Example; }, options?: any) {
        return ExampleApiFp.exampleReplaceOrCreatePostExamplesReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    exampleReplaceOrCreatePutExamples(params: {  "data"?: Example; }, options?: any) {
        return ExampleApiFp.exampleReplaceOrCreatePutExamples(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    exampleUpdateAll(params: {  "where"?: string; "data"?: Example; }, options?: any) {
        return ExampleApiFp.exampleUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    exampleUpsertWithWhere(params: {  "where"?: string; "data"?: Example; }, options?: any) {
        return ExampleApiFp.exampleUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ExampleApi - factory interface
 */
export const ExampleApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        exampleCount(params: {  "where"?: string; }, options?: any) {
            return ExampleApiFp.exampleCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        exampleCreate(params: {  "data"?: Example; }, options?: any) {
            return ExampleApiFp.exampleCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        exampleCreateChangeStreamGetExamplesChangeStream(params: {  "options"?: string; }, options?: any) {
            return ExampleApiFp.exampleCreateChangeStreamGetExamplesChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        exampleCreateChangeStreamPostExamplesChangeStream(params: {  "options"?: string; }, options?: any) {
            return ExampleApiFp.exampleCreateChangeStreamPostExamplesChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        exampleDeleteById(params: {  "id": string; }, options?: any) {
            return ExampleApiFp.exampleDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        exampleExistsGetExamplesidExists(params: {  "id": string; }, options?: any) {
            return ExampleApiFp.exampleExistsGetExamplesidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        exampleExistsHeadExamplesid(params: {  "id": string; }, options?: any) {
            return ExampleApiFp.exampleExistsHeadExamplesid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        exampleFind(params: {  "filter"?: string; }, options?: any) {
            return ExampleApiFp.exampleFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        exampleFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return ExampleApiFp.exampleFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        exampleFindOne(params: {  "filter"?: string; }, options?: any) {
            return ExampleApiFp.exampleFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        examplePatchOrCreate(params: {  "data"?: Example; }, options?: any) {
            return ExampleApiFp.examplePatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Buy by in-app purchase
         * @param id Example id
         * @param data Data must be a JSON-encoded string of Transaction model
         */
        examplePrototypeBuyIap(params: {  "id": string; "data"?: Transaction; }, options?: any) {
            return ExampleApiFp.examplePrototypeBuyIap(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Example id
         * @param data An object of model property name/value pairs
         */
        examplePrototypePatchAttributes(params: {  "id": string; "data"?: Example; }, options?: any) {
            return ExampleApiFp.examplePrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        exampleReplaceByIdPostExamplesidReplace(params: {  "id": string; "data"?: Example; }, options?: any) {
            return ExampleApiFp.exampleReplaceByIdPostExamplesidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        exampleReplaceByIdPutExamplesid(params: {  "id": string; "data"?: Example; }, options?: any) {
            return ExampleApiFp.exampleReplaceByIdPutExamplesid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        exampleReplaceOrCreatePostExamplesReplaceOrCreate(params: {  "data"?: Example; }, options?: any) {
            return ExampleApiFp.exampleReplaceOrCreatePostExamplesReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        exampleReplaceOrCreatePutExamples(params: {  "data"?: Example; }, options?: any) {
            return ExampleApiFp.exampleReplaceOrCreatePutExamples(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        exampleUpdateAll(params: {  "where"?: string; "data"?: Example; }, options?: any) {
            return ExampleApiFp.exampleUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        exampleUpsertWithWhere(params: {  "where"?: string; "data"?: Example; }, options?: any) {
            return ExampleApiFp.exampleUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * FaqApi - fetch parameter creator
 */
export const FaqApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    faqCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Faqs/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    faqCreate(params: {  "data"?: Faq; }, options?: any): FetchArgs {
        const baseUrl = `/Faqs`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    faqCreateChangeStreamGetFaqsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Faqs/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    faqCreateChangeStreamPostFaqsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Faqs/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    faqDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling faqDeleteById");
        }
        const baseUrl = `/Faqs/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    faqExistsGetFaqsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling faqExistsGetFaqsidExists");
        }
        const baseUrl = `/Faqs/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    faqExistsHeadFaqsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling faqExistsHeadFaqsid");
        }
        const baseUrl = `/Faqs/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    faqFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Faqs`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    faqFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling faqFindById");
        }
        const baseUrl = `/Faqs/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    faqFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Faqs/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    faqPatchOrCreate(params: {  "data"?: Faq; }, options?: any): FetchArgs {
        const baseUrl = `/Faqs`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Faq id
     * @param data An object of model property name/value pairs
     */
    faqPrototypePatchAttributes(params: {  "id": string; "data"?: Faq; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling faqPrototypePatchAttributes");
        }
        const baseUrl = `/Faqs/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    faqReplaceByIdPostFaqsidReplace(params: {  "id": string; "data"?: Faq; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling faqReplaceByIdPostFaqsidReplace");
        }
        const baseUrl = `/Faqs/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    faqReplaceByIdPutFaqsid(params: {  "id": string; "data"?: Faq; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling faqReplaceByIdPutFaqsid");
        }
        const baseUrl = `/Faqs/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    faqReplaceOrCreatePostFaqsReplaceOrCreate(params: {  "data"?: Faq; }, options?: any): FetchArgs {
        const baseUrl = `/Faqs/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    faqReplaceOrCreatePutFaqs(params: {  "data"?: Faq; }, options?: any): FetchArgs {
        const baseUrl = `/Faqs`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    faqUpdateAll(params: {  "where"?: string; "data"?: Faq; }, options?: any): FetchArgs {
        const baseUrl = `/Faqs/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    faqUpsertWithWhere(params: {  "where"?: string; "data"?: Faq; }, options?: any): FetchArgs {
        const baseUrl = `/Faqs/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * FaqApi - functional programming interface
 */
export const FaqApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    faqCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = FaqApiFetchParamCreator.faqCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    faqCreate(params: { "data"?: Faq;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Faq> {
        const fetchArgs = FaqApiFetchParamCreator.faqCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    faqCreateChangeStreamGetFaqsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = FaqApiFetchParamCreator.faqCreateChangeStreamGetFaqsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    faqCreateChangeStreamPostFaqsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = FaqApiFetchParamCreator.faqCreateChangeStreamPostFaqsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    faqDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = FaqApiFetchParamCreator.faqDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    faqExistsGetFaqsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = FaqApiFetchParamCreator.faqExistsGetFaqsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    faqExistsHeadFaqsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = FaqApiFetchParamCreator.faqExistsHeadFaqsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    faqFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Faq>> {
        const fetchArgs = FaqApiFetchParamCreator.faqFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    faqFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Faq> {
        const fetchArgs = FaqApiFetchParamCreator.faqFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    faqFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Faq> {
        const fetchArgs = FaqApiFetchParamCreator.faqFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    faqPatchOrCreate(params: { "data"?: Faq;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Faq> {
        const fetchArgs = FaqApiFetchParamCreator.faqPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Faq id
     * @param data An object of model property name/value pairs
     */
    faqPrototypePatchAttributes(params: { "id": string; "data"?: Faq;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Faq> {
        const fetchArgs = FaqApiFetchParamCreator.faqPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    faqReplaceByIdPostFaqsidReplace(params: { "id": string; "data"?: Faq;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Faq> {
        const fetchArgs = FaqApiFetchParamCreator.faqReplaceByIdPostFaqsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    faqReplaceByIdPutFaqsid(params: { "id": string; "data"?: Faq;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Faq> {
        const fetchArgs = FaqApiFetchParamCreator.faqReplaceByIdPutFaqsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    faqReplaceOrCreatePostFaqsReplaceOrCreate(params: { "data"?: Faq;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Faq> {
        const fetchArgs = FaqApiFetchParamCreator.faqReplaceOrCreatePostFaqsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    faqReplaceOrCreatePutFaqs(params: { "data"?: Faq;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Faq> {
        const fetchArgs = FaqApiFetchParamCreator.faqReplaceOrCreatePutFaqs(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    faqUpdateAll(params: { "where"?: string; "data"?: Faq;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = FaqApiFetchParamCreator.faqUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    faqUpsertWithWhere(params: { "where"?: string; "data"?: Faq;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Faq> {
        const fetchArgs = FaqApiFetchParamCreator.faqUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * FaqApi - object-oriented interface
 */
export class FaqApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    faqCount(params: {  "where"?: string; }, options?: any) {
        return FaqApiFp.faqCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    faqCreate(params: {  "data"?: Faq; }, options?: any) {
        return FaqApiFp.faqCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    faqCreateChangeStreamGetFaqsChangeStream(params: {  "options"?: string; }, options?: any) {
        return FaqApiFp.faqCreateChangeStreamGetFaqsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    faqCreateChangeStreamPostFaqsChangeStream(params: {  "options"?: string; }, options?: any) {
        return FaqApiFp.faqCreateChangeStreamPostFaqsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    faqDeleteById(params: {  "id": string; }, options?: any) {
        return FaqApiFp.faqDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    faqExistsGetFaqsidExists(params: {  "id": string; }, options?: any) {
        return FaqApiFp.faqExistsGetFaqsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    faqExistsHeadFaqsid(params: {  "id": string; }, options?: any) {
        return FaqApiFp.faqExistsHeadFaqsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    faqFind(params: {  "filter"?: string; }, options?: any) {
        return FaqApiFp.faqFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    faqFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return FaqApiFp.faqFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    faqFindOne(params: {  "filter"?: string; }, options?: any) {
        return FaqApiFp.faqFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    faqPatchOrCreate(params: {  "data"?: Faq; }, options?: any) {
        return FaqApiFp.faqPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Faq id
     * @param data An object of model property name/value pairs
     */
    faqPrototypePatchAttributes(params: {  "id": string; "data"?: Faq; }, options?: any) {
        return FaqApiFp.faqPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    faqReplaceByIdPostFaqsidReplace(params: {  "id": string; "data"?: Faq; }, options?: any) {
        return FaqApiFp.faqReplaceByIdPostFaqsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    faqReplaceByIdPutFaqsid(params: {  "id": string; "data"?: Faq; }, options?: any) {
        return FaqApiFp.faqReplaceByIdPutFaqsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    faqReplaceOrCreatePostFaqsReplaceOrCreate(params: {  "data"?: Faq; }, options?: any) {
        return FaqApiFp.faqReplaceOrCreatePostFaqsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    faqReplaceOrCreatePutFaqs(params: {  "data"?: Faq; }, options?: any) {
        return FaqApiFp.faqReplaceOrCreatePutFaqs(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    faqUpdateAll(params: {  "where"?: string; "data"?: Faq; }, options?: any) {
        return FaqApiFp.faqUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    faqUpsertWithWhere(params: {  "where"?: string; "data"?: Faq; }, options?: any) {
        return FaqApiFp.faqUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * FaqApi - factory interface
 */
export const FaqApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        faqCount(params: {  "where"?: string; }, options?: any) {
            return FaqApiFp.faqCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        faqCreate(params: {  "data"?: Faq; }, options?: any) {
            return FaqApiFp.faqCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        faqCreateChangeStreamGetFaqsChangeStream(params: {  "options"?: string; }, options?: any) {
            return FaqApiFp.faqCreateChangeStreamGetFaqsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        faqCreateChangeStreamPostFaqsChangeStream(params: {  "options"?: string; }, options?: any) {
            return FaqApiFp.faqCreateChangeStreamPostFaqsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        faqDeleteById(params: {  "id": string; }, options?: any) {
            return FaqApiFp.faqDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        faqExistsGetFaqsidExists(params: {  "id": string; }, options?: any) {
            return FaqApiFp.faqExistsGetFaqsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        faqExistsHeadFaqsid(params: {  "id": string; }, options?: any) {
            return FaqApiFp.faqExistsHeadFaqsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        faqFind(params: {  "filter"?: string; }, options?: any) {
            return FaqApiFp.faqFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        faqFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return FaqApiFp.faqFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        faqFindOne(params: {  "filter"?: string; }, options?: any) {
            return FaqApiFp.faqFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        faqPatchOrCreate(params: {  "data"?: Faq; }, options?: any) {
            return FaqApiFp.faqPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Faq id
         * @param data An object of model property name/value pairs
         */
        faqPrototypePatchAttributes(params: {  "id": string; "data"?: Faq; }, options?: any) {
            return FaqApiFp.faqPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        faqReplaceByIdPostFaqsidReplace(params: {  "id": string; "data"?: Faq; }, options?: any) {
            return FaqApiFp.faqReplaceByIdPostFaqsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        faqReplaceByIdPutFaqsid(params: {  "id": string; "data"?: Faq; }, options?: any) {
            return FaqApiFp.faqReplaceByIdPutFaqsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        faqReplaceOrCreatePostFaqsReplaceOrCreate(params: {  "data"?: Faq; }, options?: any) {
            return FaqApiFp.faqReplaceOrCreatePostFaqsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        faqReplaceOrCreatePutFaqs(params: {  "data"?: Faq; }, options?: any) {
            return FaqApiFp.faqReplaceOrCreatePutFaqs(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        faqUpdateAll(params: {  "where"?: string; "data"?: Faq; }, options?: any) {
            return FaqApiFp.faqUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        faqUpsertWithWhere(params: {  "where"?: string; "data"?: Faq; }, options?: any) {
            return FaqApiFp.faqUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * InstallationApi - fetch parameter creator
 */
export const InstallationApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    installationCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Installations/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    installationCreate(params: {  "data"?: Installation; }, options?: any): FetchArgs {
        const baseUrl = `/Installations`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    installationCreateChangeStreamGetInstallationsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Installations/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    installationCreateChangeStreamPostInstallationsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Installations/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    installationDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling installationDeleteById");
        }
        const baseUrl = `/Installations/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    installationExistsGetInstallationsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling installationExistsGetInstallationsidExists");
        }
        const baseUrl = `/Installations/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    installationExistsHeadInstallationsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling installationExistsHeadInstallationsid");
        }
        const baseUrl = `/Installations/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    installationFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Installations`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find installations by application id
     * @param deviceType Device type
     * @param appId Application id
     * @param appVersion Application version
     */
    installationFindByApp(params: {  "deviceType"?: string; "appId"?: string; "appVersion"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Installations/byApp`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "deviceType": params["deviceType"],
            "appId": params["appId"],
            "appVersion": params["appVersion"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    installationFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling installationFindById");
        }
        const baseUrl = `/Installations/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find installations by subscriptions
     * @param deviceType Device type
     * @param subscriptions Subscriptions
     */
    installationFindBySubscriptions(params: {  "deviceType"?: string; "subscriptions"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Installations/bySubscriptions`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "deviceType": params["deviceType"],
            "subscriptions": params["subscriptions"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find installations by user id
     * @param deviceType Device type
     * @param userId User id
     */
    installationFindByUser(params: {  "deviceType"?: string; "userId"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Installations/byUser`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "deviceType": params["deviceType"],
            "userId": params["userId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    installationFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Installations/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    installationPatchOrCreate(params: {  "data"?: Installation; }, options?: any): FetchArgs {
        const baseUrl = `/Installations`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Installation id
     * @param data An object of model property name/value pairs
     */
    installationPrototypePatchAttributes(params: {  "id": string; "data"?: Installation; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling installationPrototypePatchAttributes");
        }
        const baseUrl = `/Installations/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    installationReplaceByIdPostInstallationsidReplace(params: {  "id": string; "data"?: Installation; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling installationReplaceByIdPostInstallationsidReplace");
        }
        const baseUrl = `/Installations/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    installationReplaceByIdPutInstallationsid(params: {  "id": string; "data"?: Installation; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling installationReplaceByIdPutInstallationsid");
        }
        const baseUrl = `/Installations/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    installationReplaceOrCreatePostInstallationsReplaceOrCreate(params: {  "data"?: Installation; }, options?: any): FetchArgs {
        const baseUrl = `/Installations/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    installationReplaceOrCreatePutInstallations(params: {  "data"?: Installation; }, options?: any): FetchArgs {
        const baseUrl = `/Installations`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    installationUpdateAll(params: {  "where"?: string; "data"?: Installation; }, options?: any): FetchArgs {
        const baseUrl = `/Installations/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    installationUpsertWithWhere(params: {  "where"?: string; "data"?: Installation; }, options?: any): FetchArgs {
        const baseUrl = `/Installations/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * InstallationApi - functional programming interface
 */
export const InstallationApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    installationCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = InstallationApiFetchParamCreator.installationCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    installationCreate(params: { "data"?: Installation;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Installation> {
        const fetchArgs = InstallationApiFetchParamCreator.installationCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    installationCreateChangeStreamGetInstallationsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InstallationApiFetchParamCreator.installationCreateChangeStreamGetInstallationsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    installationCreateChangeStreamPostInstallationsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InstallationApiFetchParamCreator.installationCreateChangeStreamPostInstallationsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    installationDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InstallationApiFetchParamCreator.installationDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    installationExistsGetInstallationsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = InstallationApiFetchParamCreator.installationExistsGetInstallationsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    installationExistsHeadInstallationsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = InstallationApiFetchParamCreator.installationExistsHeadInstallationsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    installationFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Installation>> {
        const fetchArgs = InstallationApiFetchParamCreator.installationFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find installations by application id
     * @param deviceType Device type
     * @param appId Application id
     * @param appVersion Application version
     */
    installationFindByApp(params: { "deviceType"?: string; "appId"?: string; "appVersion"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InstallationApiFetchParamCreator.installationFindByApp(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    installationFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Installation> {
        const fetchArgs = InstallationApiFetchParamCreator.installationFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find installations by subscriptions
     * @param deviceType Device type
     * @param subscriptions Subscriptions
     */
    installationFindBySubscriptions(params: { "deviceType"?: string; "subscriptions"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InstallationApiFetchParamCreator.installationFindBySubscriptions(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find installations by user id
     * @param deviceType Device type
     * @param userId User id
     */
    installationFindByUser(params: { "deviceType"?: string; "userId"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InstallationApiFetchParamCreator.installationFindByUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    installationFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Installation> {
        const fetchArgs = InstallationApiFetchParamCreator.installationFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    installationPatchOrCreate(params: { "data"?: Installation;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Installation> {
        const fetchArgs = InstallationApiFetchParamCreator.installationPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Installation id
     * @param data An object of model property name/value pairs
     */
    installationPrototypePatchAttributes(params: { "id": string; "data"?: Installation;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Installation> {
        const fetchArgs = InstallationApiFetchParamCreator.installationPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    installationReplaceByIdPostInstallationsidReplace(params: { "id": string; "data"?: Installation;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Installation> {
        const fetchArgs = InstallationApiFetchParamCreator.installationReplaceByIdPostInstallationsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    installationReplaceByIdPutInstallationsid(params: { "id": string; "data"?: Installation;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Installation> {
        const fetchArgs = InstallationApiFetchParamCreator.installationReplaceByIdPutInstallationsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    installationReplaceOrCreatePostInstallationsReplaceOrCreate(params: { "data"?: Installation;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Installation> {
        const fetchArgs = InstallationApiFetchParamCreator.installationReplaceOrCreatePostInstallationsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    installationReplaceOrCreatePutInstallations(params: { "data"?: Installation;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Installation> {
        const fetchArgs = InstallationApiFetchParamCreator.installationReplaceOrCreatePutInstallations(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    installationUpdateAll(params: { "where"?: string; "data"?: Installation;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = InstallationApiFetchParamCreator.installationUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    installationUpsertWithWhere(params: { "where"?: string; "data"?: Installation;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Installation> {
        const fetchArgs = InstallationApiFetchParamCreator.installationUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * InstallationApi - object-oriented interface
 */
export class InstallationApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    installationCount(params: {  "where"?: string; }, options?: any) {
        return InstallationApiFp.installationCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    installationCreate(params: {  "data"?: Installation; }, options?: any) {
        return InstallationApiFp.installationCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    installationCreateChangeStreamGetInstallationsChangeStream(params: {  "options"?: string; }, options?: any) {
        return InstallationApiFp.installationCreateChangeStreamGetInstallationsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    installationCreateChangeStreamPostInstallationsChangeStream(params: {  "options"?: string; }, options?: any) {
        return InstallationApiFp.installationCreateChangeStreamPostInstallationsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    installationDeleteById(params: {  "id": string; }, options?: any) {
        return InstallationApiFp.installationDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    installationExistsGetInstallationsidExists(params: {  "id": string; }, options?: any) {
        return InstallationApiFp.installationExistsGetInstallationsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    installationExistsHeadInstallationsid(params: {  "id": string; }, options?: any) {
        return InstallationApiFp.installationExistsHeadInstallationsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    installationFind(params: {  "filter"?: string; }, options?: any) {
        return InstallationApiFp.installationFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find installations by application id
     * @param deviceType Device type
     * @param appId Application id
     * @param appVersion Application version
     */
    installationFindByApp(params: {  "deviceType"?: string; "appId"?: string; "appVersion"?: string; }, options?: any) {
        return InstallationApiFp.installationFindByApp(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    installationFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return InstallationApiFp.installationFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find installations by subscriptions
     * @param deviceType Device type
     * @param subscriptions Subscriptions
     */
    installationFindBySubscriptions(params: {  "deviceType"?: string; "subscriptions"?: string; }, options?: any) {
        return InstallationApiFp.installationFindBySubscriptions(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find installations by user id
     * @param deviceType Device type
     * @param userId User id
     */
    installationFindByUser(params: {  "deviceType"?: string; "userId"?: string; }, options?: any) {
        return InstallationApiFp.installationFindByUser(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    installationFindOne(params: {  "filter"?: string; }, options?: any) {
        return InstallationApiFp.installationFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    installationPatchOrCreate(params: {  "data"?: Installation; }, options?: any) {
        return InstallationApiFp.installationPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Installation id
     * @param data An object of model property name/value pairs
     */
    installationPrototypePatchAttributes(params: {  "id": string; "data"?: Installation; }, options?: any) {
        return InstallationApiFp.installationPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    installationReplaceByIdPostInstallationsidReplace(params: {  "id": string; "data"?: Installation; }, options?: any) {
        return InstallationApiFp.installationReplaceByIdPostInstallationsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    installationReplaceByIdPutInstallationsid(params: {  "id": string; "data"?: Installation; }, options?: any) {
        return InstallationApiFp.installationReplaceByIdPutInstallationsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    installationReplaceOrCreatePostInstallationsReplaceOrCreate(params: {  "data"?: Installation; }, options?: any) {
        return InstallationApiFp.installationReplaceOrCreatePostInstallationsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    installationReplaceOrCreatePutInstallations(params: {  "data"?: Installation; }, options?: any) {
        return InstallationApiFp.installationReplaceOrCreatePutInstallations(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    installationUpdateAll(params: {  "where"?: string; "data"?: Installation; }, options?: any) {
        return InstallationApiFp.installationUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    installationUpsertWithWhere(params: {  "where"?: string; "data"?: Installation; }, options?: any) {
        return InstallationApiFp.installationUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * InstallationApi - factory interface
 */
export const InstallationApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        installationCount(params: {  "where"?: string; }, options?: any) {
            return InstallationApiFp.installationCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        installationCreate(params: {  "data"?: Installation; }, options?: any) {
            return InstallationApiFp.installationCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        installationCreateChangeStreamGetInstallationsChangeStream(params: {  "options"?: string; }, options?: any) {
            return InstallationApiFp.installationCreateChangeStreamGetInstallationsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        installationCreateChangeStreamPostInstallationsChangeStream(params: {  "options"?: string; }, options?: any) {
            return InstallationApiFp.installationCreateChangeStreamPostInstallationsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        installationDeleteById(params: {  "id": string; }, options?: any) {
            return InstallationApiFp.installationDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        installationExistsGetInstallationsidExists(params: {  "id": string; }, options?: any) {
            return InstallationApiFp.installationExistsGetInstallationsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        installationExistsHeadInstallationsid(params: {  "id": string; }, options?: any) {
            return InstallationApiFp.installationExistsHeadInstallationsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        installationFind(params: {  "filter"?: string; }, options?: any) {
            return InstallationApiFp.installationFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find installations by application id
         * @param deviceType Device type
         * @param appId Application id
         * @param appVersion Application version
         */
        installationFindByApp(params: {  "deviceType"?: string; "appId"?: string; "appVersion"?: string; }, options?: any) {
            return InstallationApiFp.installationFindByApp(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        installationFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return InstallationApiFp.installationFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find installations by subscriptions
         * @param deviceType Device type
         * @param subscriptions Subscriptions
         */
        installationFindBySubscriptions(params: {  "deviceType"?: string; "subscriptions"?: string; }, options?: any) {
            return InstallationApiFp.installationFindBySubscriptions(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find installations by user id
         * @param deviceType Device type
         * @param userId User id
         */
        installationFindByUser(params: {  "deviceType"?: string; "userId"?: string; }, options?: any) {
            return InstallationApiFp.installationFindByUser(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        installationFindOne(params: {  "filter"?: string; }, options?: any) {
            return InstallationApiFp.installationFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        installationPatchOrCreate(params: {  "data"?: Installation; }, options?: any) {
            return InstallationApiFp.installationPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Installation id
         * @param data An object of model property name/value pairs
         */
        installationPrototypePatchAttributes(params: {  "id": string; "data"?: Installation; }, options?: any) {
            return InstallationApiFp.installationPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        installationReplaceByIdPostInstallationsidReplace(params: {  "id": string; "data"?: Installation; }, options?: any) {
            return InstallationApiFp.installationReplaceByIdPostInstallationsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        installationReplaceByIdPutInstallationsid(params: {  "id": string; "data"?: Installation; }, options?: any) {
            return InstallationApiFp.installationReplaceByIdPutInstallationsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        installationReplaceOrCreatePostInstallationsReplaceOrCreate(params: {  "data"?: Installation; }, options?: any) {
            return InstallationApiFp.installationReplaceOrCreatePostInstallationsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        installationReplaceOrCreatePutInstallations(params: {  "data"?: Installation; }, options?: any) {
            return InstallationApiFp.installationReplaceOrCreatePutInstallations(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        installationUpdateAll(params: {  "where"?: string; "data"?: Installation; }, options?: any) {
            return InstallationApiFp.installationUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        installationUpsertWithWhere(params: {  "where"?: string; "data"?: Installation; }, options?: any) {
            return InstallationApiFp.installationUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * NotificationApi - fetch parameter creator
 */
export const NotificationApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    notificationCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Notifications/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    notificationCreate(params: {  "data"?: Notification; }, options?: any): FetchArgs {
        const baseUrl = `/Notifications`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    notificationCreateChangeStreamGetNotificationsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Notifications/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    notificationCreateChangeStreamPostNotificationsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Notifications/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    notificationDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling notificationDeleteById");
        }
        const baseUrl = `/Notifications/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    notificationExistsGetNotificationsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling notificationExistsGetNotificationsidExists");
        }
        const baseUrl = `/Notifications/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    notificationExistsHeadNotificationsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling notificationExistsHeadNotificationsid");
        }
        const baseUrl = `/Notifications/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    notificationFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Notifications`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    notificationFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling notificationFindById");
        }
        const baseUrl = `/Notifications/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    notificationFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Notifications/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    notificationPatchOrCreate(params: {  "data"?: Notification; }, options?: any): FetchArgs {
        const baseUrl = `/Notifications`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Notification id
     * @param data An object of model property name/value pairs
     */
    notificationPrototypePatchAttributes(params: {  "id": string; "data"?: Notification; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling notificationPrototypePatchAttributes");
        }
        const baseUrl = `/Notifications/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    notificationReplaceByIdPostNotificationsidReplace(params: {  "id": string; "data"?: Notification; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling notificationReplaceByIdPostNotificationsidReplace");
        }
        const baseUrl = `/Notifications/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    notificationReplaceByIdPutNotificationsid(params: {  "id": string; "data"?: Notification; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling notificationReplaceByIdPutNotificationsid");
        }
        const baseUrl = `/Notifications/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    notificationReplaceOrCreatePostNotificationsReplaceOrCreate(params: {  "data"?: Notification; }, options?: any): FetchArgs {
        const baseUrl = `/Notifications/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    notificationReplaceOrCreatePutNotifications(params: {  "data"?: Notification; }, options?: any): FetchArgs {
        const baseUrl = `/Notifications`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    notificationUpdateAll(params: {  "where"?: string; "data"?: Notification; }, options?: any): FetchArgs {
        const baseUrl = `/Notifications/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    notificationUpsertWithWhere(params: {  "where"?: string; "data"?: Notification; }, options?: any): FetchArgs {
        const baseUrl = `/Notifications/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * NotificationApi - functional programming interface
 */
export const NotificationApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    notificationCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    notificationCreate(params: { "data"?: Notification;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Notification> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    notificationCreateChangeStreamGetNotificationsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationCreateChangeStreamGetNotificationsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    notificationCreateChangeStreamPostNotificationsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationCreateChangeStreamPostNotificationsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    notificationDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    notificationExistsGetNotificationsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationExistsGetNotificationsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    notificationExistsHeadNotificationsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationExistsHeadNotificationsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    notificationFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Notification>> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    notificationFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Notification> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    notificationFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Notification> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    notificationPatchOrCreate(params: { "data"?: Notification;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Notification> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Notification id
     * @param data An object of model property name/value pairs
     */
    notificationPrototypePatchAttributes(params: { "id": string; "data"?: Notification;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Notification> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    notificationReplaceByIdPostNotificationsidReplace(params: { "id": string; "data"?: Notification;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Notification> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationReplaceByIdPostNotificationsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    notificationReplaceByIdPutNotificationsid(params: { "id": string; "data"?: Notification;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Notification> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationReplaceByIdPutNotificationsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    notificationReplaceOrCreatePostNotificationsReplaceOrCreate(params: { "data"?: Notification;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Notification> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationReplaceOrCreatePostNotificationsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    notificationReplaceOrCreatePutNotifications(params: { "data"?: Notification;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Notification> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationReplaceOrCreatePutNotifications(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    notificationUpdateAll(params: { "where"?: string; "data"?: Notification;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    notificationUpsertWithWhere(params: { "where"?: string; "data"?: Notification;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Notification> {
        const fetchArgs = NotificationApiFetchParamCreator.notificationUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * NotificationApi - object-oriented interface
 */
export class NotificationApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    notificationCount(params: {  "where"?: string; }, options?: any) {
        return NotificationApiFp.notificationCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    notificationCreate(params: {  "data"?: Notification; }, options?: any) {
        return NotificationApiFp.notificationCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    notificationCreateChangeStreamGetNotificationsChangeStream(params: {  "options"?: string; }, options?: any) {
        return NotificationApiFp.notificationCreateChangeStreamGetNotificationsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    notificationCreateChangeStreamPostNotificationsChangeStream(params: {  "options"?: string; }, options?: any) {
        return NotificationApiFp.notificationCreateChangeStreamPostNotificationsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    notificationDeleteById(params: {  "id": string; }, options?: any) {
        return NotificationApiFp.notificationDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    notificationExistsGetNotificationsidExists(params: {  "id": string; }, options?: any) {
        return NotificationApiFp.notificationExistsGetNotificationsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    notificationExistsHeadNotificationsid(params: {  "id": string; }, options?: any) {
        return NotificationApiFp.notificationExistsHeadNotificationsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    notificationFind(params: {  "filter"?: string; }, options?: any) {
        return NotificationApiFp.notificationFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    notificationFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return NotificationApiFp.notificationFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    notificationFindOne(params: {  "filter"?: string; }, options?: any) {
        return NotificationApiFp.notificationFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    notificationPatchOrCreate(params: {  "data"?: Notification; }, options?: any) {
        return NotificationApiFp.notificationPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Notification id
     * @param data An object of model property name/value pairs
     */
    notificationPrototypePatchAttributes(params: {  "id": string; "data"?: Notification; }, options?: any) {
        return NotificationApiFp.notificationPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    notificationReplaceByIdPostNotificationsidReplace(params: {  "id": string; "data"?: Notification; }, options?: any) {
        return NotificationApiFp.notificationReplaceByIdPostNotificationsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    notificationReplaceByIdPutNotificationsid(params: {  "id": string; "data"?: Notification; }, options?: any) {
        return NotificationApiFp.notificationReplaceByIdPutNotificationsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    notificationReplaceOrCreatePostNotificationsReplaceOrCreate(params: {  "data"?: Notification; }, options?: any) {
        return NotificationApiFp.notificationReplaceOrCreatePostNotificationsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    notificationReplaceOrCreatePutNotifications(params: {  "data"?: Notification; }, options?: any) {
        return NotificationApiFp.notificationReplaceOrCreatePutNotifications(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    notificationUpdateAll(params: {  "where"?: string; "data"?: Notification; }, options?: any) {
        return NotificationApiFp.notificationUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    notificationUpsertWithWhere(params: {  "where"?: string; "data"?: Notification; }, options?: any) {
        return NotificationApiFp.notificationUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * NotificationApi - factory interface
 */
export const NotificationApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        notificationCount(params: {  "where"?: string; }, options?: any) {
            return NotificationApiFp.notificationCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        notificationCreate(params: {  "data"?: Notification; }, options?: any) {
            return NotificationApiFp.notificationCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        notificationCreateChangeStreamGetNotificationsChangeStream(params: {  "options"?: string; }, options?: any) {
            return NotificationApiFp.notificationCreateChangeStreamGetNotificationsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        notificationCreateChangeStreamPostNotificationsChangeStream(params: {  "options"?: string; }, options?: any) {
            return NotificationApiFp.notificationCreateChangeStreamPostNotificationsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        notificationDeleteById(params: {  "id": string; }, options?: any) {
            return NotificationApiFp.notificationDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        notificationExistsGetNotificationsidExists(params: {  "id": string; }, options?: any) {
            return NotificationApiFp.notificationExistsGetNotificationsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        notificationExistsHeadNotificationsid(params: {  "id": string; }, options?: any) {
            return NotificationApiFp.notificationExistsHeadNotificationsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        notificationFind(params: {  "filter"?: string; }, options?: any) {
            return NotificationApiFp.notificationFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        notificationFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return NotificationApiFp.notificationFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        notificationFindOne(params: {  "filter"?: string; }, options?: any) {
            return NotificationApiFp.notificationFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        notificationPatchOrCreate(params: {  "data"?: Notification; }, options?: any) {
            return NotificationApiFp.notificationPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Notification id
         * @param data An object of model property name/value pairs
         */
        notificationPrototypePatchAttributes(params: {  "id": string; "data"?: Notification; }, options?: any) {
            return NotificationApiFp.notificationPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        notificationReplaceByIdPostNotificationsidReplace(params: {  "id": string; "data"?: Notification; }, options?: any) {
            return NotificationApiFp.notificationReplaceByIdPostNotificationsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        notificationReplaceByIdPutNotificationsid(params: {  "id": string; "data"?: Notification; }, options?: any) {
            return NotificationApiFp.notificationReplaceByIdPutNotificationsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        notificationReplaceOrCreatePostNotificationsReplaceOrCreate(params: {  "data"?: Notification; }, options?: any) {
            return NotificationApiFp.notificationReplaceOrCreatePostNotificationsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        notificationReplaceOrCreatePutNotifications(params: {  "data"?: Notification; }, options?: any) {
            return NotificationApiFp.notificationReplaceOrCreatePutNotifications(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        notificationUpdateAll(params: {  "where"?: string; "data"?: Notification; }, options?: any) {
            return NotificationApiFp.notificationUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        notificationUpsertWithWhere(params: {  "where"?: string; "data"?: Notification; }, options?: any) {
            return NotificationApiFp.notificationUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * RoleApi - fetch parameter creator
 */
export const RoleApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    roleCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Roles/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    roleCreate(params: {  "data"?: Role; }, options?: any): FetchArgs {
        const baseUrl = `/Roles`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    roleCreateChangeStreamGetRolesChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Roles/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    roleCreateChangeStreamPostRolesChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Roles/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    roleDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleDeleteById");
        }
        const baseUrl = `/Roles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    roleExistsGetRolesidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleExistsGetRolesidExists");
        }
        const baseUrl = `/Roles/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    roleExistsHeadRolesid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleExistsHeadRolesid");
        }
        const baseUrl = `/Roles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    roleFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Roles`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    roleFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleFindById");
        }
        const baseUrl = `/Roles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    roleFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Roles/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    rolePatchOrCreate(params: {  "data"?: Role; }, options?: any): FetchArgs {
        const baseUrl = `/Roles`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts principals of Role.
     * @param id Role id
     * @param where Criteria to match model instances
     */
    rolePrototypeCountPrincipals(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling rolePrototypeCountPrincipals");
        }
        const baseUrl = `/Roles/{id}/principals/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in principals of this model.
     * @param id Role id
     * @param data 
     */
    rolePrototypeCreatePrincipals(params: {  "id": string; "data"?: RoleMapping; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling rolePrototypeCreatePrincipals");
        }
        const baseUrl = `/Roles/{id}/principals`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all principals of this model.
     * @param id Role id
     */
    rolePrototypeDeletePrincipals(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling rolePrototypeDeletePrincipals");
        }
        const baseUrl = `/Roles/{id}/principals`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for principals.
     * @param id Role id
     * @param fk Foreign key for principals
     */
    rolePrototypeDestroyByIdPrincipals(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling rolePrototypeDestroyByIdPrincipals");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling rolePrototypeDestroyByIdPrincipals");
        }
        const baseUrl = `/Roles/{id}/principals/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for principals.
     * @param id Role id
     * @param fk Foreign key for principals
     */
    rolePrototypeFindByIdPrincipals(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling rolePrototypeFindByIdPrincipals");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling rolePrototypeFindByIdPrincipals");
        }
        const baseUrl = `/Roles/{id}/principals/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries principals of Role.
     * @param id Role id
     * @param filter 
     */
    rolePrototypeGetPrincipals(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling rolePrototypeGetPrincipals");
        }
        const baseUrl = `/Roles/{id}/principals`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Role id
     * @param data An object of model property name/value pairs
     */
    rolePrototypePatchAttributes(params: {  "id": string; "data"?: Role; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling rolePrototypePatchAttributes");
        }
        const baseUrl = `/Roles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for principals.
     * @param id Role id
     * @param fk Foreign key for principals
     * @param data 
     */
    rolePrototypeUpdateByIdPrincipals(params: {  "id": string; "fk": string; "data"?: RoleMapping; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling rolePrototypeUpdateByIdPrincipals");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling rolePrototypeUpdateByIdPrincipals");
        }
        const baseUrl = `/Roles/{id}/principals/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    roleReplaceByIdPostRolesidReplace(params: {  "id": string; "data"?: Role; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleReplaceByIdPostRolesidReplace");
        }
        const baseUrl = `/Roles/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    roleReplaceByIdPutRolesid(params: {  "id": string; "data"?: Role; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleReplaceByIdPutRolesid");
        }
        const baseUrl = `/Roles/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleReplaceOrCreatePostRolesReplaceOrCreate(params: {  "data"?: Role; }, options?: any): FetchArgs {
        const baseUrl = `/Roles/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleReplaceOrCreatePutRoles(params: {  "data"?: Role; }, options?: any): FetchArgs {
        const baseUrl = `/Roles`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    roleUpdateAll(params: {  "where"?: string; "data"?: Role; }, options?: any): FetchArgs {
        const baseUrl = `/Roles/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    roleUpsertWithWhere(params: {  "where"?: string; "data"?: Role; }, options?: any): FetchArgs {
        const baseUrl = `/Roles/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * RoleApi - functional programming interface
 */
export const RoleApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    roleCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = RoleApiFetchParamCreator.roleCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    roleCreate(params: { "data"?: Role;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = RoleApiFetchParamCreator.roleCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    roleCreateChangeStreamGetRolesChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RoleApiFetchParamCreator.roleCreateChangeStreamGetRolesChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    roleCreateChangeStreamPostRolesChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RoleApiFetchParamCreator.roleCreateChangeStreamPostRolesChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    roleDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RoleApiFetchParamCreator.roleDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    roleExistsGetRolesidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = RoleApiFetchParamCreator.roleExistsGetRolesidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    roleExistsHeadRolesid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = RoleApiFetchParamCreator.roleExistsHeadRolesid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    roleFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Role>> {
        const fetchArgs = RoleApiFetchParamCreator.roleFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    roleFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = RoleApiFetchParamCreator.roleFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    roleFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = RoleApiFetchParamCreator.roleFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    rolePatchOrCreate(params: { "data"?: Role;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = RoleApiFetchParamCreator.rolePatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts principals of Role.
     * @param id Role id
     * @param where Criteria to match model instances
     */
    rolePrototypeCountPrincipals(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = RoleApiFetchParamCreator.rolePrototypeCountPrincipals(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in principals of this model.
     * @param id Role id
     * @param data 
     */
    rolePrototypeCreatePrincipals(params: { "id": string; "data"?: RoleMapping;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = RoleApiFetchParamCreator.rolePrototypeCreatePrincipals(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all principals of this model.
     * @param id Role id
     */
    rolePrototypeDeletePrincipals(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RoleApiFetchParamCreator.rolePrototypeDeletePrincipals(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for principals.
     * @param id Role id
     * @param fk Foreign key for principals
     */
    rolePrototypeDestroyByIdPrincipals(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RoleApiFetchParamCreator.rolePrototypeDestroyByIdPrincipals(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for principals.
     * @param id Role id
     * @param fk Foreign key for principals
     */
    rolePrototypeFindByIdPrincipals(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = RoleApiFetchParamCreator.rolePrototypeFindByIdPrincipals(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries principals of Role.
     * @param id Role id
     * @param filter 
     */
    rolePrototypeGetPrincipals(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RoleMapping>> {
        const fetchArgs = RoleApiFetchParamCreator.rolePrototypeGetPrincipals(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Role id
     * @param data An object of model property name/value pairs
     */
    rolePrototypePatchAttributes(params: { "id": string; "data"?: Role;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = RoleApiFetchParamCreator.rolePrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for principals.
     * @param id Role id
     * @param fk Foreign key for principals
     * @param data 
     */
    rolePrototypeUpdateByIdPrincipals(params: { "id": string; "fk": string; "data"?: RoleMapping;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = RoleApiFetchParamCreator.rolePrototypeUpdateByIdPrincipals(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    roleReplaceByIdPostRolesidReplace(params: { "id": string; "data"?: Role;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = RoleApiFetchParamCreator.roleReplaceByIdPostRolesidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    roleReplaceByIdPutRolesid(params: { "id": string; "data"?: Role;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = RoleApiFetchParamCreator.roleReplaceByIdPutRolesid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleReplaceOrCreatePostRolesReplaceOrCreate(params: { "data"?: Role;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = RoleApiFetchParamCreator.roleReplaceOrCreatePostRolesReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleReplaceOrCreatePutRoles(params: { "data"?: Role;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = RoleApiFetchParamCreator.roleReplaceOrCreatePutRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    roleUpdateAll(params: { "where"?: string; "data"?: Role;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = RoleApiFetchParamCreator.roleUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    roleUpsertWithWhere(params: { "where"?: string; "data"?: Role;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = RoleApiFetchParamCreator.roleUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * RoleApi - object-oriented interface
 */
export class RoleApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    roleCount(params: {  "where"?: string; }, options?: any) {
        return RoleApiFp.roleCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    roleCreate(params: {  "data"?: Role; }, options?: any) {
        return RoleApiFp.roleCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    roleCreateChangeStreamGetRolesChangeStream(params: {  "options"?: string; }, options?: any) {
        return RoleApiFp.roleCreateChangeStreamGetRolesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    roleCreateChangeStreamPostRolesChangeStream(params: {  "options"?: string; }, options?: any) {
        return RoleApiFp.roleCreateChangeStreamPostRolesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    roleDeleteById(params: {  "id": string; }, options?: any) {
        return RoleApiFp.roleDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    roleExistsGetRolesidExists(params: {  "id": string; }, options?: any) {
        return RoleApiFp.roleExistsGetRolesidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    roleExistsHeadRolesid(params: {  "id": string; }, options?: any) {
        return RoleApiFp.roleExistsHeadRolesid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    roleFind(params: {  "filter"?: string; }, options?: any) {
        return RoleApiFp.roleFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    roleFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return RoleApiFp.roleFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    roleFindOne(params: {  "filter"?: string; }, options?: any) {
        return RoleApiFp.roleFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    rolePatchOrCreate(params: {  "data"?: Role; }, options?: any) {
        return RoleApiFp.rolePatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts principals of Role.
     * @param id Role id
     * @param where Criteria to match model instances
     */
    rolePrototypeCountPrincipals(params: {  "id": string; "where"?: string; }, options?: any) {
        return RoleApiFp.rolePrototypeCountPrincipals(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in principals of this model.
     * @param id Role id
     * @param data 
     */
    rolePrototypeCreatePrincipals(params: {  "id": string; "data"?: RoleMapping; }, options?: any) {
        return RoleApiFp.rolePrototypeCreatePrincipals(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all principals of this model.
     * @param id Role id
     */
    rolePrototypeDeletePrincipals(params: {  "id": string; }, options?: any) {
        return RoleApiFp.rolePrototypeDeletePrincipals(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for principals.
     * @param id Role id
     * @param fk Foreign key for principals
     */
    rolePrototypeDestroyByIdPrincipals(params: {  "id": string; "fk": string; }, options?: any) {
        return RoleApiFp.rolePrototypeDestroyByIdPrincipals(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for principals.
     * @param id Role id
     * @param fk Foreign key for principals
     */
    rolePrototypeFindByIdPrincipals(params: {  "id": string; "fk": string; }, options?: any) {
        return RoleApiFp.rolePrototypeFindByIdPrincipals(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries principals of Role.
     * @param id Role id
     * @param filter 
     */
    rolePrototypeGetPrincipals(params: {  "id": string; "filter"?: string; }, options?: any) {
        return RoleApiFp.rolePrototypeGetPrincipals(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Role id
     * @param data An object of model property name/value pairs
     */
    rolePrototypePatchAttributes(params: {  "id": string; "data"?: Role; }, options?: any) {
        return RoleApiFp.rolePrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for principals.
     * @param id Role id
     * @param fk Foreign key for principals
     * @param data 
     */
    rolePrototypeUpdateByIdPrincipals(params: {  "id": string; "fk": string; "data"?: RoleMapping; }, options?: any) {
        return RoleApiFp.rolePrototypeUpdateByIdPrincipals(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    roleReplaceByIdPostRolesidReplace(params: {  "id": string; "data"?: Role; }, options?: any) {
        return RoleApiFp.roleReplaceByIdPostRolesidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    roleReplaceByIdPutRolesid(params: {  "id": string; "data"?: Role; }, options?: any) {
        return RoleApiFp.roleReplaceByIdPutRolesid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleReplaceOrCreatePostRolesReplaceOrCreate(params: {  "data"?: Role; }, options?: any) {
        return RoleApiFp.roleReplaceOrCreatePostRolesReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleReplaceOrCreatePutRoles(params: {  "data"?: Role; }, options?: any) {
        return RoleApiFp.roleReplaceOrCreatePutRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    roleUpdateAll(params: {  "where"?: string; "data"?: Role; }, options?: any) {
        return RoleApiFp.roleUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    roleUpsertWithWhere(params: {  "where"?: string; "data"?: Role; }, options?: any) {
        return RoleApiFp.roleUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * RoleApi - factory interface
 */
export const RoleApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        roleCount(params: {  "where"?: string; }, options?: any) {
            return RoleApiFp.roleCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        roleCreate(params: {  "data"?: Role; }, options?: any) {
            return RoleApiFp.roleCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        roleCreateChangeStreamGetRolesChangeStream(params: {  "options"?: string; }, options?: any) {
            return RoleApiFp.roleCreateChangeStreamGetRolesChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        roleCreateChangeStreamPostRolesChangeStream(params: {  "options"?: string; }, options?: any) {
            return RoleApiFp.roleCreateChangeStreamPostRolesChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        roleDeleteById(params: {  "id": string; }, options?: any) {
            return RoleApiFp.roleDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        roleExistsGetRolesidExists(params: {  "id": string; }, options?: any) {
            return RoleApiFp.roleExistsGetRolesidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        roleExistsHeadRolesid(params: {  "id": string; }, options?: any) {
            return RoleApiFp.roleExistsHeadRolesid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        roleFind(params: {  "filter"?: string; }, options?: any) {
            return RoleApiFp.roleFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        roleFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return RoleApiFp.roleFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        roleFindOne(params: {  "filter"?: string; }, options?: any) {
            return RoleApiFp.roleFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        rolePatchOrCreate(params: {  "data"?: Role; }, options?: any) {
            return RoleApiFp.rolePatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts principals of Role.
         * @param id Role id
         * @param where Criteria to match model instances
         */
        rolePrototypeCountPrincipals(params: {  "id": string; "where"?: string; }, options?: any) {
            return RoleApiFp.rolePrototypeCountPrincipals(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in principals of this model.
         * @param id Role id
         * @param data 
         */
        rolePrototypeCreatePrincipals(params: {  "id": string; "data"?: RoleMapping; }, options?: any) {
            return RoleApiFp.rolePrototypeCreatePrincipals(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all principals of this model.
         * @param id Role id
         */
        rolePrototypeDeletePrincipals(params: {  "id": string; }, options?: any) {
            return RoleApiFp.rolePrototypeDeletePrincipals(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for principals.
         * @param id Role id
         * @param fk Foreign key for principals
         */
        rolePrototypeDestroyByIdPrincipals(params: {  "id": string; "fk": string; }, options?: any) {
            return RoleApiFp.rolePrototypeDestroyByIdPrincipals(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for principals.
         * @param id Role id
         * @param fk Foreign key for principals
         */
        rolePrototypeFindByIdPrincipals(params: {  "id": string; "fk": string; }, options?: any) {
            return RoleApiFp.rolePrototypeFindByIdPrincipals(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries principals of Role.
         * @param id Role id
         * @param filter 
         */
        rolePrototypeGetPrincipals(params: {  "id": string; "filter"?: string; }, options?: any) {
            return RoleApiFp.rolePrototypeGetPrincipals(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Role id
         * @param data An object of model property name/value pairs
         */
        rolePrototypePatchAttributes(params: {  "id": string; "data"?: Role; }, options?: any) {
            return RoleApiFp.rolePrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for principals.
         * @param id Role id
         * @param fk Foreign key for principals
         * @param data 
         */
        rolePrototypeUpdateByIdPrincipals(params: {  "id": string; "fk": string; "data"?: RoleMapping; }, options?: any) {
            return RoleApiFp.rolePrototypeUpdateByIdPrincipals(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        roleReplaceByIdPostRolesidReplace(params: {  "id": string; "data"?: Role; }, options?: any) {
            return RoleApiFp.roleReplaceByIdPostRolesidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        roleReplaceByIdPutRolesid(params: {  "id": string; "data"?: Role; }, options?: any) {
            return RoleApiFp.roleReplaceByIdPutRolesid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        roleReplaceOrCreatePostRolesReplaceOrCreate(params: {  "data"?: Role; }, options?: any) {
            return RoleApiFp.roleReplaceOrCreatePostRolesReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        roleReplaceOrCreatePutRoles(params: {  "data"?: Role; }, options?: any) {
            return RoleApiFp.roleReplaceOrCreatePutRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        roleUpdateAll(params: {  "where"?: string; "data"?: Role; }, options?: any) {
            return RoleApiFp.roleUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        roleUpsertWithWhere(params: {  "where"?: string; "data"?: Role; }, options?: any) {
            return RoleApiFp.roleUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * RoleMappingApi - fetch parameter creator
 */
export const RoleMappingApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    roleMappingCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/RoleMappings/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    roleMappingCreate(params: {  "data"?: RoleMapping; }, options?: any): FetchArgs {
        const baseUrl = `/RoleMappings`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    roleMappingCreateChangeStreamGetRoleMappingsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/RoleMappings/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    roleMappingCreateChangeStreamPostRoleMappingsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/RoleMappings/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    roleMappingDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleMappingDeleteById");
        }
        const baseUrl = `/RoleMappings/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    roleMappingExistsGetRoleMappingsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleMappingExistsGetRoleMappingsidExists");
        }
        const baseUrl = `/RoleMappings/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    roleMappingExistsHeadRoleMappingsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleMappingExistsHeadRoleMappingsid");
        }
        const baseUrl = `/RoleMappings/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    roleMappingFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/RoleMappings`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    roleMappingFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleMappingFindById");
        }
        const baseUrl = `/RoleMappings/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    roleMappingFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/RoleMappings/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleMappingPatchOrCreate(params: {  "data"?: RoleMapping; }, options?: any): FetchArgs {
        const baseUrl = `/RoleMappings`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation role.
     * @param id RoleMapping id
     * @param refresh 
     */
    roleMappingPrototypeGetRole(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleMappingPrototypeGetRole");
        }
        const baseUrl = `/RoleMappings/{id}/role`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id RoleMapping id
     * @param data An object of model property name/value pairs
     */
    roleMappingPrototypePatchAttributes(params: {  "id": string; "data"?: RoleMapping; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleMappingPrototypePatchAttributes");
        }
        const baseUrl = `/RoleMappings/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    roleMappingReplaceByIdPostRoleMappingsidReplace(params: {  "id": string; "data"?: RoleMapping; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleMappingReplaceByIdPostRoleMappingsidReplace");
        }
        const baseUrl = `/RoleMappings/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    roleMappingReplaceByIdPutRoleMappingsid(params: {  "id": string; "data"?: RoleMapping; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling roleMappingReplaceByIdPutRoleMappingsid");
        }
        const baseUrl = `/RoleMappings/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleMappingReplaceOrCreatePostRoleMappingsReplaceOrCreate(params: {  "data"?: RoleMapping; }, options?: any): FetchArgs {
        const baseUrl = `/RoleMappings/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleMappingReplaceOrCreatePutRoleMappings(params: {  "data"?: RoleMapping; }, options?: any): FetchArgs {
        const baseUrl = `/RoleMappings`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    roleMappingUpdateAll(params: {  "where"?: string; "data"?: RoleMapping; }, options?: any): FetchArgs {
        const baseUrl = `/RoleMappings/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    roleMappingUpsertWithWhere(params: {  "where"?: string; "data"?: RoleMapping; }, options?: any): FetchArgs {
        const baseUrl = `/RoleMappings/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * RoleMappingApi - functional programming interface
 */
export const RoleMappingApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    roleMappingCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    roleMappingCreate(params: { "data"?: RoleMapping;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    roleMappingCreateChangeStreamGetRoleMappingsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingCreateChangeStreamGetRoleMappingsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    roleMappingCreateChangeStreamPostRoleMappingsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingCreateChangeStreamPostRoleMappingsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    roleMappingDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    roleMappingExistsGetRoleMappingsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingExistsGetRoleMappingsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    roleMappingExistsHeadRoleMappingsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingExistsHeadRoleMappingsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    roleMappingFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RoleMapping>> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    roleMappingFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    roleMappingFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleMappingPatchOrCreate(params: { "data"?: RoleMapping;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation role.
     * @param id RoleMapping id
     * @param refresh 
     */
    roleMappingPrototypeGetRole(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingPrototypeGetRole(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id RoleMapping id
     * @param data An object of model property name/value pairs
     */
    roleMappingPrototypePatchAttributes(params: { "id": string; "data"?: RoleMapping;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    roleMappingReplaceByIdPostRoleMappingsidReplace(params: { "id": string; "data"?: RoleMapping;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingReplaceByIdPostRoleMappingsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    roleMappingReplaceByIdPutRoleMappingsid(params: { "id": string; "data"?: RoleMapping;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingReplaceByIdPutRoleMappingsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleMappingReplaceOrCreatePostRoleMappingsReplaceOrCreate(params: { "data"?: RoleMapping;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingReplaceOrCreatePostRoleMappingsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleMappingReplaceOrCreatePutRoleMappings(params: { "data"?: RoleMapping;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingReplaceOrCreatePutRoleMappings(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    roleMappingUpdateAll(params: { "where"?: string; "data"?: RoleMapping;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    roleMappingUpsertWithWhere(params: { "where"?: string; "data"?: RoleMapping;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = RoleMappingApiFetchParamCreator.roleMappingUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * RoleMappingApi - object-oriented interface
 */
export class RoleMappingApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    roleMappingCount(params: {  "where"?: string; }, options?: any) {
        return RoleMappingApiFp.roleMappingCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    roleMappingCreate(params: {  "data"?: RoleMapping; }, options?: any) {
        return RoleMappingApiFp.roleMappingCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    roleMappingCreateChangeStreamGetRoleMappingsChangeStream(params: {  "options"?: string; }, options?: any) {
        return RoleMappingApiFp.roleMappingCreateChangeStreamGetRoleMappingsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    roleMappingCreateChangeStreamPostRoleMappingsChangeStream(params: {  "options"?: string; }, options?: any) {
        return RoleMappingApiFp.roleMappingCreateChangeStreamPostRoleMappingsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    roleMappingDeleteById(params: {  "id": string; }, options?: any) {
        return RoleMappingApiFp.roleMappingDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    roleMappingExistsGetRoleMappingsidExists(params: {  "id": string; }, options?: any) {
        return RoleMappingApiFp.roleMappingExistsGetRoleMappingsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    roleMappingExistsHeadRoleMappingsid(params: {  "id": string; }, options?: any) {
        return RoleMappingApiFp.roleMappingExistsHeadRoleMappingsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    roleMappingFind(params: {  "filter"?: string; }, options?: any) {
        return RoleMappingApiFp.roleMappingFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    roleMappingFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return RoleMappingApiFp.roleMappingFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    roleMappingFindOne(params: {  "filter"?: string; }, options?: any) {
        return RoleMappingApiFp.roleMappingFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleMappingPatchOrCreate(params: {  "data"?: RoleMapping; }, options?: any) {
        return RoleMappingApiFp.roleMappingPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation role.
     * @param id RoleMapping id
     * @param refresh 
     */
    roleMappingPrototypeGetRole(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return RoleMappingApiFp.roleMappingPrototypeGetRole(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id RoleMapping id
     * @param data An object of model property name/value pairs
     */
    roleMappingPrototypePatchAttributes(params: {  "id": string; "data"?: RoleMapping; }, options?: any) {
        return RoleMappingApiFp.roleMappingPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    roleMappingReplaceByIdPostRoleMappingsidReplace(params: {  "id": string; "data"?: RoleMapping; }, options?: any) {
        return RoleMappingApiFp.roleMappingReplaceByIdPostRoleMappingsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    roleMappingReplaceByIdPutRoleMappingsid(params: {  "id": string; "data"?: RoleMapping; }, options?: any) {
        return RoleMappingApiFp.roleMappingReplaceByIdPutRoleMappingsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleMappingReplaceOrCreatePostRoleMappingsReplaceOrCreate(params: {  "data"?: RoleMapping; }, options?: any) {
        return RoleMappingApiFp.roleMappingReplaceOrCreatePostRoleMappingsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    roleMappingReplaceOrCreatePutRoleMappings(params: {  "data"?: RoleMapping; }, options?: any) {
        return RoleMappingApiFp.roleMappingReplaceOrCreatePutRoleMappings(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    roleMappingUpdateAll(params: {  "where"?: string; "data"?: RoleMapping; }, options?: any) {
        return RoleMappingApiFp.roleMappingUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    roleMappingUpsertWithWhere(params: {  "where"?: string; "data"?: RoleMapping; }, options?: any) {
        return RoleMappingApiFp.roleMappingUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * RoleMappingApi - factory interface
 */
export const RoleMappingApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        roleMappingCount(params: {  "where"?: string; }, options?: any) {
            return RoleMappingApiFp.roleMappingCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        roleMappingCreate(params: {  "data"?: RoleMapping; }, options?: any) {
            return RoleMappingApiFp.roleMappingCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        roleMappingCreateChangeStreamGetRoleMappingsChangeStream(params: {  "options"?: string; }, options?: any) {
            return RoleMappingApiFp.roleMappingCreateChangeStreamGetRoleMappingsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        roleMappingCreateChangeStreamPostRoleMappingsChangeStream(params: {  "options"?: string; }, options?: any) {
            return RoleMappingApiFp.roleMappingCreateChangeStreamPostRoleMappingsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        roleMappingDeleteById(params: {  "id": string; }, options?: any) {
            return RoleMappingApiFp.roleMappingDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        roleMappingExistsGetRoleMappingsidExists(params: {  "id": string; }, options?: any) {
            return RoleMappingApiFp.roleMappingExistsGetRoleMappingsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        roleMappingExistsHeadRoleMappingsid(params: {  "id": string; }, options?: any) {
            return RoleMappingApiFp.roleMappingExistsHeadRoleMappingsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        roleMappingFind(params: {  "filter"?: string; }, options?: any) {
            return RoleMappingApiFp.roleMappingFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        roleMappingFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return RoleMappingApiFp.roleMappingFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        roleMappingFindOne(params: {  "filter"?: string; }, options?: any) {
            return RoleMappingApiFp.roleMappingFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        roleMappingPatchOrCreate(params: {  "data"?: RoleMapping; }, options?: any) {
            return RoleMappingApiFp.roleMappingPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation role.
         * @param id RoleMapping id
         * @param refresh 
         */
        roleMappingPrototypeGetRole(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return RoleMappingApiFp.roleMappingPrototypeGetRole(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id RoleMapping id
         * @param data An object of model property name/value pairs
         */
        roleMappingPrototypePatchAttributes(params: {  "id": string; "data"?: RoleMapping; }, options?: any) {
            return RoleMappingApiFp.roleMappingPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        roleMappingReplaceByIdPostRoleMappingsidReplace(params: {  "id": string; "data"?: RoleMapping; }, options?: any) {
            return RoleMappingApiFp.roleMappingReplaceByIdPostRoleMappingsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        roleMappingReplaceByIdPutRoleMappingsid(params: {  "id": string; "data"?: RoleMapping; }, options?: any) {
            return RoleMappingApiFp.roleMappingReplaceByIdPutRoleMappingsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        roleMappingReplaceOrCreatePostRoleMappingsReplaceOrCreate(params: {  "data"?: RoleMapping; }, options?: any) {
            return RoleMappingApiFp.roleMappingReplaceOrCreatePostRoleMappingsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        roleMappingReplaceOrCreatePutRoleMappings(params: {  "data"?: RoleMapping; }, options?: any) {
            return RoleMappingApiFp.roleMappingReplaceOrCreatePutRoleMappings(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        roleMappingUpdateAll(params: {  "where"?: string; "data"?: RoleMapping; }, options?: any) {
            return RoleMappingApiFp.roleMappingUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        roleMappingUpsertWithWhere(params: {  "where"?: string; "data"?: RoleMapping; }, options?: any) {
            return RoleMappingApiFp.roleMappingUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * UserApi - fetch parameter creator
 */
export const UserApiFetchParamCreator = {
    /**
     * 
     * @summary Change a user's password.
     * @param oldPassword 
     * @param newPassword 
     */
    userChangePassword(params: {  "oldPassword": string; "newPassword": string; }, options?: any): FetchArgs {
        // verify required parameter "oldPassword" is set
        if (params["oldPassword"] == null) {
            throw new Error("Missing required parameter oldPassword when calling userChangePassword");
        }
        // verify required parameter "newPassword" is set
        if (params["newPassword"] == null) {
            throw new Error("Missing required parameter newPassword when calling userChangePassword");
        }
        const baseUrl = `/Users/change-password`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "oldPassword": params["oldPassword"],
            "newPassword": params["newPassword"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Confirm a user registration with identity verification token.
     * @param uid 
     * @param token 
     * @param redirect 
     */
    userConfirm(params: {  "uid": string; "token": string; "redirect"?: string; }, options?: any): FetchArgs {
        // verify required parameter "uid" is set
        if (params["uid"] == null) {
            throw new Error("Missing required parameter uid when calling userConfirm");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            throw new Error("Missing required parameter token when calling userConfirm");
        }
        const baseUrl = `/Users/confirm`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "uid": params["uid"],
            "token": params["token"],
            "redirect": params["redirect"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    userCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Users/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    userCreate(params: {  "data"?: User; }, options?: any): FetchArgs {
        const baseUrl = `/Users`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    userCreateChangeStreamGetUsersChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Users/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    userCreateChangeStreamPostUsersChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Users/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    userDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userDeleteById");
        }
        const baseUrl = `/Users/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    userExistsGetUsersidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userExistsGetUsersidExists");
        }
        const baseUrl = `/Users/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    userExistsHeadUsersid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userExistsHeadUsersid");
        }
        const baseUrl = `/Users/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    userFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Users`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    userFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userFindById");
        }
        const baseUrl = `/Users/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    userFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Users/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Login a user with username/email and password.
     * @param credentials 
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    userLogin(params: {  "credentials": any; "include"?: string; }, options?: any): FetchArgs {
        // verify required parameter "credentials" is set
        if (params["credentials"] == null) {
            throw new Error("Missing required parameter credentials when calling userLogin");
        }
        const baseUrl = `/Users/login`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "include": params["include"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["credentials"]) {
            fetchOptions.body = JSON.stringify(params["credentials"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Logout a user with access token.
     */
    userLogout(options?: any): FetchArgs {
        const baseUrl = `/Users/logout`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userPatchOrCreate(params: {  "data"?: User; }, options?: any): FetchArgs {
        const baseUrl = `/Users`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts accessTokens of User.
     * @param id User id
     * @param where Criteria to match model instances
     */
    userPrototypeCountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userPrototypeCountAccessTokens");
        }
        const baseUrl = `/Users/{id}/accessTokens/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id User id
     * @param data 
     */
    userPrototypeCreateAccessTokens(params: {  "id": string; "data"?: AccessToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userPrototypeCreateAccessTokens");
        }
        const baseUrl = `/Users/{id}/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id User id
     */
    userPrototypeDeleteAccessTokens(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userPrototypeDeleteAccessTokens");
        }
        const baseUrl = `/Users/{id}/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     */
    userPrototypeDestroyByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userPrototypeDestroyByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling userPrototypeDestroyByIdAccessTokens");
        }
        const baseUrl = `/Users/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     */
    userPrototypeFindByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userPrototypeFindByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling userPrototypeFindByIdAccessTokens");
        }
        const baseUrl = `/Users/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries accessTokens of User.
     * @param id User id
     * @param filter 
     */
    userPrototypeGetAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userPrototypeGetAccessTokens");
        }
        const baseUrl = `/Users/{id}/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id User id
     * @param data An object of model property name/value pairs
     */
    userPrototypePatchAttributes(params: {  "id": string; "data"?: User; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userPrototypePatchAttributes");
        }
        const baseUrl = `/Users/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    userPrototypeUpdateByIdAccessTokens(params: {  "id": string; "fk": string; "data"?: AccessToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userPrototypeUpdateByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling userPrototypeUpdateByIdAccessTokens");
        }
        const baseUrl = `/Users/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id User id
     */
    userPrototypeVerify(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userPrototypeVerify");
        }
        const baseUrl = `/Users/{id}/verify`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    userReplaceByIdPostUsersidReplace(params: {  "id": string; "data"?: User; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userReplaceByIdPostUsersidReplace");
        }
        const baseUrl = `/Users/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    userReplaceByIdPutUsersid(params: {  "id": string; "data"?: User; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling userReplaceByIdPutUsersid");
        }
        const baseUrl = `/Users/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userReplaceOrCreatePostUsersReplaceOrCreate(params: {  "data"?: User; }, options?: any): FetchArgs {
        const baseUrl = `/Users/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userReplaceOrCreatePutUsers(params: {  "data"?: User; }, options?: any): FetchArgs {
        const baseUrl = `/Users`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Reset password for a user with email.
     * @param options 
     */
    userResetPassword(params: {  "options": any; }, options?: any): FetchArgs {
        // verify required parameter "options" is set
        if (params["options"] == null) {
            throw new Error("Missing required parameter options when calling userResetPassword");
        }
        const baseUrl = `/Users/reset`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["options"]) {
            fetchOptions.body = JSON.stringify(params["options"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Reset user's password via a password-reset token.
     * @param newPassword 
     */
    userSetPassword(params: {  "newPassword": string; }, options?: any): FetchArgs {
        // verify required parameter "newPassword" is set
        if (params["newPassword"] == null) {
            throw new Error("Missing required parameter newPassword when calling userSetPassword");
        }
        const baseUrl = `/Users/reset-password`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "newPassword": params["newPassword"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    userUpdateAll(params: {  "where"?: string; "data"?: User; }, options?: any): FetchArgs {
        const baseUrl = `/Users/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    userUpsertWithWhere(params: {  "where"?: string; "data"?: User; }, options?: any): FetchArgs {
        const baseUrl = `/Users/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = {
    /**
     * 
     * @summary Change a user's password.
     * @param oldPassword 
     * @param newPassword 
     */
    userChangePassword(params: { "oldPassword": string; "newPassword": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.userChangePassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Confirm a user registration with identity verification token.
     * @param uid 
     * @param token 
     * @param redirect 
     */
    userConfirm(params: { "uid": string; "token": string; "redirect"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.userConfirm(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    userCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = UserApiFetchParamCreator.userCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    userCreate(params: { "data"?: User;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UserApiFetchParamCreator.userCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    userCreateChangeStreamGetUsersChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.userCreateChangeStreamGetUsersChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    userCreateChangeStreamPostUsersChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.userCreateChangeStreamPostUsersChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    userDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.userDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    userExistsGetUsersidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = UserApiFetchParamCreator.userExistsGetUsersidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    userExistsHeadUsersid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = UserApiFetchParamCreator.userExistsHeadUsersid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    userFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<User>> {
        const fetchArgs = UserApiFetchParamCreator.userFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    userFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UserApiFetchParamCreator.userFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    userFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UserApiFetchParamCreator.userFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Login a user with username/email and password.
     * @param credentials 
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    userLogin(params: { "credentials": any; "include"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.userLogin(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Logout a user with access token.
     */
    userLogout(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.userLogout(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userPatchOrCreate(params: { "data"?: User;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UserApiFetchParamCreator.userPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts accessTokens of User.
     * @param id User id
     * @param where Criteria to match model instances
     */
    userPrototypeCountAccessTokens(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = UserApiFetchParamCreator.userPrototypeCountAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id User id
     * @param data 
     */
    userPrototypeCreateAccessTokens(params: { "id": string; "data"?: AccessToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccessToken> {
        const fetchArgs = UserApiFetchParamCreator.userPrototypeCreateAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id User id
     */
    userPrototypeDeleteAccessTokens(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.userPrototypeDeleteAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     */
    userPrototypeDestroyByIdAccessTokens(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.userPrototypeDestroyByIdAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     */
    userPrototypeFindByIdAccessTokens(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccessToken> {
        const fetchArgs = UserApiFetchParamCreator.userPrototypeFindByIdAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries accessTokens of User.
     * @param id User id
     * @param filter 
     */
    userPrototypeGetAccessTokens(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AccessToken>> {
        const fetchArgs = UserApiFetchParamCreator.userPrototypeGetAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id User id
     * @param data An object of model property name/value pairs
     */
    userPrototypePatchAttributes(params: { "id": string; "data"?: User;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UserApiFetchParamCreator.userPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    userPrototypeUpdateByIdAccessTokens(params: { "id": string; "fk": string; "data"?: AccessToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccessToken> {
        const fetchArgs = UserApiFetchParamCreator.userPrototypeUpdateByIdAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id User id
     */
    userPrototypeVerify(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.userPrototypeVerify(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    userReplaceByIdPostUsersidReplace(params: { "id": string; "data"?: User;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UserApiFetchParamCreator.userReplaceByIdPostUsersidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    userReplaceByIdPutUsersid(params: { "id": string; "data"?: User;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UserApiFetchParamCreator.userReplaceByIdPutUsersid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userReplaceOrCreatePostUsersReplaceOrCreate(params: { "data"?: User;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UserApiFetchParamCreator.userReplaceOrCreatePostUsersReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userReplaceOrCreatePutUsers(params: { "data"?: User;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UserApiFetchParamCreator.userReplaceOrCreatePutUsers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Reset password for a user with email.
     * @param options 
     */
    userResetPassword(params: { "options": any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.userResetPassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Reset user's password via a password-reset token.
     * @param newPassword 
     */
    userSetPassword(params: { "newPassword": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.userSetPassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    userUpdateAll(params: { "where"?: string; "data"?: User;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = UserApiFetchParamCreator.userUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    userUpsertWithWhere(params: { "where"?: string; "data"?: User;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UserApiFetchParamCreator.userUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Change a user's password.
     * @param oldPassword 
     * @param newPassword 
     */
    userChangePassword(params: {  "oldPassword": string; "newPassword": string; }, options?: any) {
        return UserApiFp.userChangePassword(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Confirm a user registration with identity verification token.
     * @param uid 
     * @param token 
     * @param redirect 
     */
    userConfirm(params: {  "uid": string; "token": string; "redirect"?: string; }, options?: any) {
        return UserApiFp.userConfirm(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    userCount(params: {  "where"?: string; }, options?: any) {
        return UserApiFp.userCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    userCreate(params: {  "data"?: User; }, options?: any) {
        return UserApiFp.userCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    userCreateChangeStreamGetUsersChangeStream(params: {  "options"?: string; }, options?: any) {
        return UserApiFp.userCreateChangeStreamGetUsersChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    userCreateChangeStreamPostUsersChangeStream(params: {  "options"?: string; }, options?: any) {
        return UserApiFp.userCreateChangeStreamPostUsersChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    userDeleteById(params: {  "id": string; }, options?: any) {
        return UserApiFp.userDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    userExistsGetUsersidExists(params: {  "id": string; }, options?: any) {
        return UserApiFp.userExistsGetUsersidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    userExistsHeadUsersid(params: {  "id": string; }, options?: any) {
        return UserApiFp.userExistsHeadUsersid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    userFind(params: {  "filter"?: string; }, options?: any) {
        return UserApiFp.userFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    userFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return UserApiFp.userFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    userFindOne(params: {  "filter"?: string; }, options?: any) {
        return UserApiFp.userFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Login a user with username/email and password.
     * @param credentials 
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    userLogin(params: {  "credentials": any; "include"?: string; }, options?: any) {
        return UserApiFp.userLogin(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Logout a user with access token.
     */
    userLogout(options?: any) {
        return UserApiFp.userLogout(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userPatchOrCreate(params: {  "data"?: User; }, options?: any) {
        return UserApiFp.userPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts accessTokens of User.
     * @param id User id
     * @param where Criteria to match model instances
     */
    userPrototypeCountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any) {
        return UserApiFp.userPrototypeCountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id User id
     * @param data 
     */
    userPrototypeCreateAccessTokens(params: {  "id": string; "data"?: AccessToken; }, options?: any) {
        return UserApiFp.userPrototypeCreateAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id User id
     */
    userPrototypeDeleteAccessTokens(params: {  "id": string; }, options?: any) {
        return UserApiFp.userPrototypeDeleteAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     */
    userPrototypeDestroyByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
        return UserApiFp.userPrototypeDestroyByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     */
    userPrototypeFindByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
        return UserApiFp.userPrototypeFindByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries accessTokens of User.
     * @param id User id
     * @param filter 
     */
    userPrototypeGetAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any) {
        return UserApiFp.userPrototypeGetAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id User id
     * @param data An object of model property name/value pairs
     */
    userPrototypePatchAttributes(params: {  "id": string; "data"?: User; }, options?: any) {
        return UserApiFp.userPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id User id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    userPrototypeUpdateByIdAccessTokens(params: {  "id": string; "fk": string; "data"?: AccessToken; }, options?: any) {
        return UserApiFp.userPrototypeUpdateByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id User id
     */
    userPrototypeVerify(params: {  "id": string; }, options?: any) {
        return UserApiFp.userPrototypeVerify(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    userReplaceByIdPostUsersidReplace(params: {  "id": string; "data"?: User; }, options?: any) {
        return UserApiFp.userReplaceByIdPostUsersidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    userReplaceByIdPutUsersid(params: {  "id": string; "data"?: User; }, options?: any) {
        return UserApiFp.userReplaceByIdPutUsersid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userReplaceOrCreatePostUsersReplaceOrCreate(params: {  "data"?: User; }, options?: any) {
        return UserApiFp.userReplaceOrCreatePostUsersReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    userReplaceOrCreatePutUsers(params: {  "data"?: User; }, options?: any) {
        return UserApiFp.userReplaceOrCreatePutUsers(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Reset password for a user with email.
     * @param options 
     */
    userResetPassword(params: {  "options": any; }, options?: any) {
        return UserApiFp.userResetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Reset user's password via a password-reset token.
     * @param newPassword 
     */
    userSetPassword(params: {  "newPassword": string; }, options?: any) {
        return UserApiFp.userSetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    userUpdateAll(params: {  "where"?: string; "data"?: User; }, options?: any) {
        return UserApiFp.userUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    userUpsertWithWhere(params: {  "where"?: string; "data"?: User; }, options?: any) {
        return UserApiFp.userUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Change a user's password.
         * @param oldPassword 
         * @param newPassword 
         */
        userChangePassword(params: {  "oldPassword": string; "newPassword": string; }, options?: any) {
            return UserApiFp.userChangePassword(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Confirm a user registration with identity verification token.
         * @param uid 
         * @param token 
         * @param redirect 
         */
        userConfirm(params: {  "uid": string; "token": string; "redirect"?: string; }, options?: any) {
            return UserApiFp.userConfirm(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        userCount(params: {  "where"?: string; }, options?: any) {
            return UserApiFp.userCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        userCreate(params: {  "data"?: User; }, options?: any) {
            return UserApiFp.userCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        userCreateChangeStreamGetUsersChangeStream(params: {  "options"?: string; }, options?: any) {
            return UserApiFp.userCreateChangeStreamGetUsersChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        userCreateChangeStreamPostUsersChangeStream(params: {  "options"?: string; }, options?: any) {
            return UserApiFp.userCreateChangeStreamPostUsersChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        userDeleteById(params: {  "id": string; }, options?: any) {
            return UserApiFp.userDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        userExistsGetUsersidExists(params: {  "id": string; }, options?: any) {
            return UserApiFp.userExistsGetUsersidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        userExistsHeadUsersid(params: {  "id": string; }, options?: any) {
            return UserApiFp.userExistsHeadUsersid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        userFind(params: {  "filter"?: string; }, options?: any) {
            return UserApiFp.userFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        userFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return UserApiFp.userFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        userFindOne(params: {  "filter"?: string; }, options?: any) {
            return UserApiFp.userFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Login a user with username/email and password.
         * @param credentials 
         * @param include Related objects to include in the response. See the description of return value for more details.
         */
        userLogin(params: {  "credentials": any; "include"?: string; }, options?: any) {
            return UserApiFp.userLogin(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Logout a user with access token.
         */
        userLogout(options?: any) {
            return UserApiFp.userLogout(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        userPatchOrCreate(params: {  "data"?: User; }, options?: any) {
            return UserApiFp.userPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts accessTokens of User.
         * @param id User id
         * @param where Criteria to match model instances
         */
        userPrototypeCountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any) {
            return UserApiFp.userPrototypeCountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in accessTokens of this model.
         * @param id User id
         * @param data 
         */
        userPrototypeCreateAccessTokens(params: {  "id": string; "data"?: AccessToken; }, options?: any) {
            return UserApiFp.userPrototypeCreateAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all accessTokens of this model.
         * @param id User id
         */
        userPrototypeDeleteAccessTokens(params: {  "id": string; }, options?: any) {
            return UserApiFp.userPrototypeDeleteAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for accessTokens.
         * @param id User id
         * @param fk Foreign key for accessTokens
         */
        userPrototypeDestroyByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
            return UserApiFp.userPrototypeDestroyByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for accessTokens.
         * @param id User id
         * @param fk Foreign key for accessTokens
         */
        userPrototypeFindByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
            return UserApiFp.userPrototypeFindByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries accessTokens of User.
         * @param id User id
         * @param filter 
         */
        userPrototypeGetAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any) {
            return UserApiFp.userPrototypeGetAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id User id
         * @param data An object of model property name/value pairs
         */
        userPrototypePatchAttributes(params: {  "id": string; "data"?: User; }, options?: any) {
            return UserApiFp.userPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for accessTokens.
         * @param id User id
         * @param fk Foreign key for accessTokens
         * @param data 
         */
        userPrototypeUpdateByIdAccessTokens(params: {  "id": string; "fk": string; "data"?: AccessToken; }, options?: any) {
            return UserApiFp.userPrototypeUpdateByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Trigger user's identity verification with configured verifyOptions
         * @param id User id
         */
        userPrototypeVerify(params: {  "id": string; }, options?: any) {
            return UserApiFp.userPrototypeVerify(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        userReplaceByIdPostUsersidReplace(params: {  "id": string; "data"?: User; }, options?: any) {
            return UserApiFp.userReplaceByIdPostUsersidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        userReplaceByIdPutUsersid(params: {  "id": string; "data"?: User; }, options?: any) {
            return UserApiFp.userReplaceByIdPutUsersid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        userReplaceOrCreatePostUsersReplaceOrCreate(params: {  "data"?: User; }, options?: any) {
            return UserApiFp.userReplaceOrCreatePostUsersReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        userReplaceOrCreatePutUsers(params: {  "data"?: User; }, options?: any) {
            return UserApiFp.userReplaceOrCreatePutUsers(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reset password for a user with email.
         * @param options 
         */
        userResetPassword(params: {  "options": any; }, options?: any) {
            return UserApiFp.userResetPassword(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reset user's password via a password-reset token.
         * @param newPassword 
         */
        userSetPassword(params: {  "newPassword": string; }, options?: any) {
            return UserApiFp.userSetPassword(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        userUpdateAll(params: {  "where"?: string; "data"?: User; }, options?: any) {
            return UserApiFp.userUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        userUpsertWithWhere(params: {  "where"?: string; "data"?: User; }, options?: any) {
            return UserApiFp.userUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};

